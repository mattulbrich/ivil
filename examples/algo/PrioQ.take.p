(* created : Thu Jul 21 21:48:44 CEST 2011 - Alpha-2 *)
#
# This file was generated by PSEUDO
# which is copyright (C) 2009 Universitaet Karlsruhe, Germany
#    written by Mattias Ulbrich
#

include "$bytecode.p"

(* Database declarations *)

#  include "listADT.p" 
  include "$decproc.p"
  
  function heap pre_h assignable
  
  properties
    BreakpointStrategy.stopAtJumpBack "false"
    BreakpointStrategy.stopAtLoop "false"
    CompoundStrategy.strategies "SimplificationStrategy,BreakpointStrategy,SMTStrategy" 


(* Program declarations *)
function
  (* local variables *)
  int _min assignable
  int _tmp assignable
  ref _this assignable
  int _result assignable
  int _last assignable
  int _i assignable
  field(ref) field_PrioQ_h unique
  field(int) field_PrioQ_size unique

(* Program *)
program P source "PrioQ.java"
    assume !_this = null 
      & !sel(h, _this, field_PrioQ_h) = null
      & 0 < sel(h, _this, field_PrioQ_size)
      & sel(h, _this, field_PrioQ_size) <= arrlen(sel(h, _this, field_PrioQ_h))
  stmt0: sourceline 17   (*    0: ldc[18](2) 4 *)
    pre_h := h
  stmt5: sourceline 18   (*    5: aload_0[42](1) *)
    st := push(st, _this)
  stmt6: sourceline 18   (*    6: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt9: sourceline 18   (*    9: iconst_0[3](1) *)
    st := push(st, 0)
  stmt10: sourceline 18   (*   10: iaload[46](1) *)
    assert !top2Ref(st) = null ; "non-null array access"
    assert topInt(st) >= 0 & topInt(st) < arrlen(top2Ref(st)) ; "array index in bounds"
    st := push(pop2(st), sel(h, top2Ref(st), intIdx(topInt(st))))
  stmt11: sourceline 18   (*   11: istore_1[60](1) *)
    _result :=  topInt(st)
    st := pop(st)
  stmt12: sourceline 19   (*   12: aload_0[42](1) *)
    st := push(st, _this)
  stmt13: sourceline 19   (*   13: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt16: sourceline 19   (*   16: aload_0[42](1) *)
    st := push(st, _this)
  stmt17: sourceline 19   (*   17: getfield[180](3) 6 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_size))
  stmt20: sourceline 19   (*   20: iconst_1[4](1) *)
    st := push(st, 1)
  stmt21: sourceline 19   (*   21: isub[100](1) *)
    st := push(pop2(st), top2Int(st) - topInt(st))
  stmt22: sourceline 19   (*   22: iaload[46](1) *)
    assert !top2Ref(st) = null ; "non-null array access"
    assert topInt(st) >= 0 & topInt(st) < arrlen(top2Ref(st)) ; "array index in bounds"
    st := push(pop2(st), sel(h, top2Ref(st), intIdx(topInt(st))))
  stmt23: sourceline 19   (*   23: istore_2[61](1) *)
    _last :=  topInt(st)
    st := pop(st)
  stmt24: sourceline 20   (*   24: aload_0[42](1) *)
    st := push(st, _this)
  stmt25: sourceline 20   (*   25: dup[89](1) *)
    st := push(st, topRef(st))
  stmt26: sourceline 20   (*   26: getfield[180](3) 6 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_size))
  stmt29: sourceline 20   (*   29: iconst_1[4](1) *)
    st := push(st, 1)
  stmt30: sourceline 20   (*   30: isub[100](1) *)
    st := push(pop2(st), top2Int(st) - topInt(st))
  stmt31: sourceline 20   (*   31: putfield[181](3) 6 *)
    assert !top2Ref(st) = null ; "non-null field access receiver"
    h := stor(h, top2Ref(st), field_PrioQ_size, topInt(st))
    st := pop2(st)
  stmt34: sourceline 22   (*   34: aload_0[42](1) *)
    st := push(st, _this)
  stmt35: sourceline 22   (*   35: getfield[180](3) 6 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_size))
  stmt38: sourceline 22   (*   38: ifne[154](3) -> aload_0 *)
    goto branch0, branch1
    branch0: assume !topInt(st) = 0
    st := pop(st)
    goto stmt43
    branch1: assume !(!topInt(st) = 0)
    st := pop(st)
  stmt41: sourceline 23   (*   41: iload_1[27](1) *)
    st := push(st, _result)
  stmt42: sourceline 23   (*   42: ireturn[172](1) *)
    exc := null
    intRet := topInt(st)
    st := pop(st)
    goto end_of_proc
  stmt43: sourceline 25   (*   43: aload_0[42](1) *)
    st := push(st, _this)
  stmt44: sourceline 25   (*   44: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt47: sourceline 25   (*   47: iconst_0[3](1) *)
    st := push(st, 0)
  stmt48: sourceline 25   (*   48: iload_2[28](1) *)
    st := push(st, _last)
  stmt49: sourceline 25   (*   49: iastore[79](1) *)
    assert !top3Ref(st) = null ; "non-null array access"
    assert top2Int(st) >= 0 & top2Int(st) < arrlen(top3Ref(st)) ; "array index in bounds"
    h := stor(h, top3Ref(st), intIdx(top2Int(st)), topInt(st))
    st := pop3(st)
  stmt50: sourceline 26   (*   50: iconst_0[3](1) *)
    st := push(st, 0)
  stmt51: sourceline 26   (*   51: istore_3[62](1) *)
    _i :=  topInt(st)
    st := pop(st)
  stmt52: sourceline 27   (*   52: ldc[18](2) 7 *)
  stmt57:
    skip LOOPINV, sel(h, _this, field_PrioQ_size) = sel(pre_h, _this, field_PrioQ_size) - 1 & sel(h, _this, field_PrioQ_h) = sel(pre_h, _this, field_PrioQ_h) & 0<=_i  ; "inlined loopinvariant"
   sourceline 30   (*   57: iload_3[29](1) *)
    st := push(st, _i)
  stmt58: sourceline 30   (*   58: aload_0[42](1) *)
    st := push(st, _this)
  stmt59: sourceline 30   (*   59: getfield[180](3) 6 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_size))
  stmt62: sourceline 30   (*   62: iconst_2[5](1) *)
    st := push(st, 2)
  stmt63: sourceline 30   (*   63: idiv[108](1) *)
    st := push(pop2(st), top2Int(st) / topInt(st))
  stmt64: sourceline 30   (*   64: if_icmpge[162](3) -> iload_1 *)
    goto branch2, branch3
    branch2: assume top2Int(st) >= topInt(st)
    st := pop2(st)
    goto stmt189
    branch3: assume !(top2Int(st) >= topInt(st))
    st := pop2(st)
  stmt67: sourceline 35   (*   67: iconst_2[5](1) *)
    st := push(st, 2)
  stmt68: sourceline 35   (*   68: iload_3[29](1) *)
    st := push(st, _i)
  stmt69: sourceline 35   (*   69: imul[104](1) *)
    st := push(pop2(st), top2Int(st) * topInt(st))
  stmt70: sourceline 35   (*   70: iconst_2[5](1) *)
    st := push(st, 2)
  stmt71: sourceline 35   (*   71: iadd[96](1) *)
    st := push(pop2(st), topInt(st) + top2Int(st))
  stmt72: sourceline 35   (*   72: aload_0[42](1) *)
    st := push(st, _this)
  stmt73: sourceline 35   (*   73: getfield[180](3) 6 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_size))
  stmt76: sourceline 35   (*   76: if_icmpne[160](3) -> aload_0 *)
    goto branch4, branch5
    branch4: assume !top2Int(st) = topInt(st)
    st := pop2(st)
    goto stmt89
    branch5: assume !(!top2Int(st) = topInt(st))
    st := pop2(st)
  stmt79: sourceline 36   (*   79: iconst_2[5](1) *)
    st := push(st, 2)
  stmt80: sourceline 36   (*   80: iload_3[29](1) *)
    st := push(st, _i)
  stmt81: sourceline 36   (*   81: imul[104](1) *)
    st := push(pop2(st), top2Int(st) * topInt(st))
  stmt82: sourceline 36   (*   82: iconst_1[4](1) *)
    st := push(st, 1)
  stmt83: sourceline 36   (*   83: iadd[96](1) *)
    st := push(pop2(st), topInt(st) + top2Int(st))
  stmt84: sourceline 36   (*   84: istore[54](2) 4 *)
    _min :=  topInt(st)
    st := pop(st)
  stmt86: sourceline 36   (*   86: goto[167](3) -> aload_0 *)
    goto stmt129
  stmt89: sourceline 37   (*   89: aload_0[42](1) *)
    st := push(st, _this)
  stmt90: sourceline 37   (*   90: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt93: sourceline 37   (*   93: iconst_2[5](1) *)
    st := push(st, 2)
  stmt94: sourceline 37   (*   94: iload_3[29](1) *)
    st := push(st, _i)
  stmt95: sourceline 37   (*   95: imul[104](1) *)
    st := push(pop2(st), top2Int(st) * topInt(st))
  stmt96: sourceline 37   (*   96: iconst_1[4](1) *)
    st := push(st, 1)
  stmt97: sourceline 37   (*   97: iadd[96](1) *)
    st := push(pop2(st), topInt(st) + top2Int(st))
  stmt98: sourceline 37   (*   98: iaload[46](1) *)
    assert !top2Ref(st) = null ; "non-null array access"
    assert topInt(st) >= 0 & topInt(st) < arrlen(top2Ref(st)) ; "array index in bounds"
    st := push(pop2(st), sel(h, top2Ref(st), intIdx(topInt(st))))
  stmt99: sourceline 37   (*   99: aload_0[42](1) *)
    st := push(st, _this)
  stmt100: sourceline 37   (*  100: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt103: sourceline 37   (*  103: iconst_2[5](1) *)
    st := push(st, 2)
  stmt104: sourceline 37   (*  104: iload_3[29](1) *)
    st := push(st, _i)
  stmt105: sourceline 37   (*  105: imul[104](1) *)
    st := push(pop2(st), top2Int(st) * topInt(st))
  stmt106: sourceline 37   (*  106: iconst_2[5](1) *)
    st := push(st, 2)
  stmt107: sourceline 37   (*  107: iadd[96](1) *)
    st := push(pop2(st), topInt(st) + top2Int(st))
  stmt108: sourceline 37   (*  108: iaload[46](1) *)
    assert !top2Ref(st) = null ; "non-null array access"
    assert topInt(st) >= 0 & topInt(st) < arrlen(top2Ref(st)) ; "array index in bounds"
    st := push(pop2(st), sel(h, top2Ref(st), intIdx(topInt(st))))
  stmt109: sourceline 37   (*  109: if_icmple[164](3) -> iconst_2 *)
    goto branch6, branch7
    branch6: assume top2Int(st) <= topInt(st)
    st := pop2(st)
    goto stmt122
    branch7: assume !(top2Int(st) <= topInt(st))
    st := pop2(st)
  stmt112: sourceline 38   (*  112: iconst_2[5](1) *)
    st := push(st, 2)
  stmt113: sourceline 38   (*  113: iload_3[29](1) *)
    st := push(st, _i)
  stmt114: sourceline 38   (*  114: imul[104](1) *)
    st := push(pop2(st), top2Int(st) * topInt(st))
  stmt115: sourceline 38   (*  115: iconst_2[5](1) *)
    st := push(st, 2)
  stmt116: sourceline 38   (*  116: iadd[96](1) *)
    st := push(pop2(st), topInt(st) + top2Int(st))
  stmt117: sourceline 38   (*  117: istore[54](2) 4 *)
    _min :=  topInt(st)
    st := pop(st)
  stmt119: sourceline 38   (*  119: goto[167](3) -> aload_0 *)
    goto stmt129
  stmt122: sourceline 40   (*  122: iconst_2[5](1) *)
    st := push(st, 2)
  stmt123: sourceline 40   (*  123: iload_3[29](1) *)
    st := push(st, _i)
  stmt124: sourceline 40   (*  124: imul[104](1) *)
    st := push(pop2(st), top2Int(st) * topInt(st))
  stmt125: sourceline 40   (*  125: iconst_1[4](1) *)
    st := push(st, 1)
  stmt126: sourceline 40   (*  126: iadd[96](1) *)
    st := push(pop2(st), topInt(st) + top2Int(st))
  stmt127: sourceline 40   (*  127: istore[54](2) 4 *)
    _min :=  topInt(st)
    st := pop(st)
  stmt129: sourceline 43   (*  129: aload_0[42](1) *)
    st := push(st, _this)
  stmt130: sourceline 43   (*  130: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt133: sourceline 43   (*  133: iload_3[29](1) *)
    st := push(st, _i)
  stmt134: sourceline 43   (*  134: iaload[46](1) *)
    assert !top2Ref(st) = null ; "non-null array access"
    assert topInt(st) >= 0 & topInt(st) < arrlen(top2Ref(st)) ; "array index in bounds"
    st := push(pop2(st), sel(h, top2Ref(st), intIdx(topInt(st))))
  stmt135: sourceline 43   (*  135: aload_0[42](1) *)
    st := push(st, _this)
  stmt136: sourceline 43   (*  136: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt139: sourceline 43   (*  139: iload[21](2) 4 *)
    st := push(st, _min)
  stmt141: sourceline 43   (*  141: iaload[46](1) *)
    assert !top2Ref(st) = null ; "non-null array access"
    assert topInt(st) >= 0 & topInt(st) < arrlen(top2Ref(st)) ; "array index in bounds"
    st := push(pop2(st), sel(h, top2Ref(st), intIdx(topInt(st))))
  stmt142: sourceline 43   (*  142: if_icmple[164](3) -> aload_0 *)
    goto branch8, branch9
    branch8: assume top2Int(st) <= topInt(st)
    st := pop2(st)
    goto stmt181
    branch9: assume !(top2Int(st) <= topInt(st))
    st := pop2(st)
  stmt145: sourceline 44   (*  145: aload_0[42](1) *)
    st := push(st, _this)
  stmt146: sourceline 44   (*  146: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt149: sourceline 44   (*  149: iload_3[29](1) *)
    st := push(st, _i)
  stmt150: sourceline 44   (*  150: iaload[46](1) *)
    assert !top2Ref(st) = null ; "non-null array access"
    assert topInt(st) >= 0 & topInt(st) < arrlen(top2Ref(st)) ; "array index in bounds"
    st := push(pop2(st), sel(h, top2Ref(st), intIdx(topInt(st))))
  stmt151: sourceline 44   (*  151: istore[54](2) 5 *)
    _tmp :=  topInt(st)
    st := pop(st)
  stmt153: sourceline 45   (*  153: aload_0[42](1) *)
    st := push(st, _this)
  stmt154: sourceline 45   (*  154: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt157: sourceline 45   (*  157: iload_3[29](1) *)
    st := push(st, _i)
  stmt158: sourceline 45   (*  158: aload_0[42](1) *)
    st := push(st, _this)
  stmt159: sourceline 45   (*  159: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt162: sourceline 45   (*  162: iload[21](2) 4 *)
    st := push(st, _min)
  stmt164: sourceline 45   (*  164: iaload[46](1) *)
    assert !top2Ref(st) = null ; "non-null array access"
    assert topInt(st) >= 0 & topInt(st) < arrlen(top2Ref(st)) ; "array index in bounds"
    st := push(pop2(st), sel(h, top2Ref(st), intIdx(topInt(st))))
  stmt165: sourceline 45   (*  165: iastore[79](1) *)
    assert !top3Ref(st) = null ; "non-null array access"
    assert top2Int(st) >= 0 & top2Int(st) < arrlen(top3Ref(st)) ; "array index in bounds"
    h := stor(h, top3Ref(st), intIdx(top2Int(st)), topInt(st))
    st := pop3(st)
  stmt166: sourceline 46   (*  166: aload_0[42](1) *)
    st := push(st, _this)
  stmt167: sourceline 46   (*  167: getfield[180](3) 3 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_h))
  stmt170: sourceline 46   (*  170: iload[21](2) 4 *)
    st := push(st, _min)
  stmt172: sourceline 46   (*  172: iload[21](2) 5 *)
    st := push(st, _tmp)
  stmt174: sourceline 46   (*  174: iastore[79](1) *)
    assert !top3Ref(st) = null ; "non-null array access"
    assert top2Int(st) >= 0 & top2Int(st) < arrlen(top3Ref(st)) ; "array index in bounds"
    h := stor(h, top3Ref(st), intIdx(top2Int(st)), topInt(st))
    st := pop3(st)
  stmt175: sourceline 47   (*  175: iload[21](2) 4 *)
    st := push(st, _min)
  stmt177: sourceline 47   (*  177: istore_3[62](1) *)
    _i :=  topInt(st)
    st := pop(st)
  stmt178: sourceline 48   (*  178: goto[167](3) -> goto -> 57 *)
    goto stmt186
  stmt181: sourceline 49   (*  181: aload_0[42](1) *)
    st := push(st, _this)
  stmt182: sourceline 49   (*  182: getfield[180](3) 6 *)
    assert !topRef(st) = null ; "non-null field access receiver"
    st := push(pop(st), sel(h, topRef(st), field_PrioQ_size))
  stmt185: sourceline 49   (*  185: istore_3[62](1) *)
    _i :=  topInt(st)
    st := pop(st)
  stmt186: sourceline 53   (*  186: goto[167](3) -> iload_3 *)
    goto stmt57
  stmt189: sourceline 55   (*  189: iload_1[27](1) *)
    st := push(st, _result)
  stmt190: sourceline 55   (*  190: ireturn[172](1) *)
    exc := null
    intRet := topInt(st)
    st := pop(st)
    goto end_of_proc
    end_of_proc:
    assert true
(* end of program *)

problem [0 ; P]true

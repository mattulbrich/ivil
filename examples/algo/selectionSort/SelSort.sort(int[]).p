(* created : Thu Feb 28 23:34:11 CET 2013 - Alpha-3 *)
#
# This file was generated by PSEUDO
# which is copyright (C) 2009 Universitaet Karlsruhe, Germany
#    written by Mattias Ulbrich
#

include "$bytecode.p"
include "$intRange.p"
include "declarations.p"

(* program variables *)
function
   ref _array assignable (* local variable '1' *)
   ref pre_array assignable (* method parameter, prestate *)
   bool st_0_bool assignable (* stack variable *)
   int st_0_int assignable (* stack variable *)
   int _i assignable (* local variable '2' *)
   ref st_1_ref assignable (* stack variable *)
   int st_1_int assignable (* stack variable *)
   bool st_2_bool assignable (* stack variable *)
   int st_2_int assignable (* stack variable *)
   bool branchCond assignable (* branching condition *)
   int _t assignable (* local variable '3' *)
   bool st_1_bool assignable (* stack variable *)
   int _j assignable (* local variable '4' *)
   ref st_0_ref assignable (* stack variable *)
   int _tmp assignable (* local variable '4' *)
   ref st_2_ref assignable (* stack variable *)
   int st_3_int assignable (* stack variable *)

(* the translated Java program *)
program Java source "./SelSort.jspec"
   sourceline 4
    assume !_array = null ; "Assume precondition"
   sourceline 5
    assume !_array = _this ; "Assume precondition"
    assume wellformed(h) ; "assumption guaranteed by Java"
    assume !_this = null ; "assumption guaranteed by Java"
    assume h[_this, created] ; "assumption guaranteed by Java"
    assume typeof(_this) = C_SelSort ; "assumption of the runtime type"
    assume subtype(typeof(_array), array_int) ; "Typing of argument"
    pre_h := h || pre_array := _array ; "Recording the prestate"
    decrBase := 0 ; "Save the decrease (variant) base"
  Label1:
   sourceline 9
    (* ICONST_0 *)
    st_0_bool := false
    st_0_int := 0
    (* ISTORE *)
    _i := st_0_int
  Label2:
    (* ILOAD *)
    st_0_int := _i
    (* ALOAD *)
    st_1_ref := _array
    (* ARRAYLENGTH *)
    assert !st_1_ref = null ; "non-null array reference"
    st_1_int := arrlen(st_1_ref)
    (* ICONST_1 *)
    st_2_bool := true
    st_2_int := 1
    (* ISUB *)
    st_1_int := st_1_int - st_2_int
    (* IF_ICMPGE *)
    branchCond := st_0_int >= st_1_int
    goto Label3, Label4
  Label3:
    assume branchCond
    goto Label5
  Label4:
    assume !branchCond
  Label6:
   sourceline 10
    (* ILOAD *)
    st_0_int := _i
    (* ISTORE *)
    _t := st_0_int
  Label7:
   sourceline 11
    (* ILOAD *)
    st_0_int := _i
    (* ICONST_1 *)
    st_1_bool := true
    st_1_int := 1
    (* IADD *)
    st_0_int := st_0_int + st_1_int
    (* ISTORE *)
    _j := st_0_int
  Label8:
    (* ILOAD *)
    st_0_int := _j
    (* ALOAD *)
    st_1_ref := _array
    (* ARRAYLENGTH *)
    assert !st_1_ref = null ; "non-null array reference"
    st_1_int := arrlen(st_1_ref)
    (* IF_ICMPGE *)
    branchCond := st_0_int >= st_1_int
    goto Label9, Label10
  Label9:
    assume branchCond
    goto Label11
  Label10:
    assume !branchCond
  Label12:
   sourceline 12
    (* ALOAD *)
    st_0_ref := _array
    (* ILOAD *)
    st_1_int := _j
    (* IALOAD *)
    assert !st_0_ref = null ; "non-null array access"
    assert st_1_int >= 0 & st_1_int < arrlen(st_0_ref) ; "array index in bounds"
    st_0_int := h[st_0_ref, idxInt(st_1_int)] ; "read value from array"
    (* ALOAD *)
    st_1_ref := _array
    (* ILOAD *)
    st_2_int := _t
    (* IALOAD *)
    assert !st_1_ref = null ; "non-null array access"
    assert st_2_int >= 0 & st_2_int < arrlen(st_1_ref) ; "array index in bounds"
    st_1_int := h[st_1_ref, idxInt(st_2_int)] ; "read value from array"
    (* IF_ICMPGE *)
    branchCond := st_0_int >= st_1_int
    goto Label13, Label14
  Label13:
    assume branchCond
    goto Label15
  Label14:
    assume !branchCond
  Label16:
   sourceline 13
    (* ILOAD *)
    st_0_int := _j
    (* ISTORE *)
    _t := st_0_int
  Label15:
   sourceline 15
    (* LDC + INVOKESTATIC - Specification injection *)
    skip MARK, 1
  Label17:
   sourceline 11
    (* IINC *)
    _j := _j + 1
    (* GOTO *)
    goto Label8
  Label11:
   sourceline 17
    (* ALOAD *)
    st_0_ref := _array
    (* ILOAD *)
    st_1_int := _i
    (* IALOAD *)
    assert !st_0_ref = null ; "non-null array access"
    assert st_1_int >= 0 & st_1_int < arrlen(st_0_ref) ; "array index in bounds"
    st_0_int := h[st_0_ref, idxInt(st_1_int)] ; "read value from array"
    (* ISTORE *)
    _tmp := st_0_int
  Label18:
   sourceline 18
    (* ALOAD *)
    st_0_ref := _array
    (* ILOAD *)
    st_1_int := _i
    (* ALOAD *)
    st_2_ref := _array
    (* ILOAD *)
    st_3_int := _t
    (* IALOAD *)
    assert !st_2_ref = null ; "non-null array access"
    assert st_3_int >= 0 & st_3_int < arrlen(st_2_ref) ; "array index in bounds"
    st_2_int := h[st_2_ref, idxInt(st_3_int)] ; "read value from array"
    (* IASTORE *)
    assert !st_0_ref = null ; "non-null array access"
    assert st_1_int >= 0 & st_1_int < arrlen(st_0_ref) ; "array index in bounds"
    h := h[st_0_ref, idxInt(st_1_int) := st_2_int]
  Label19:
   sourceline 19
    (* ALOAD *)
    st_0_ref := _array
    (* ILOAD *)
    st_1_int := _t
    (* ILOAD *)
    st_2_int := _tmp
    (* IASTORE *)
    assert !st_0_ref = null ; "non-null array access"
    assert st_1_int >= 0 & st_1_int < arrlen(st_0_ref) ; "array index in bounds"
    h := h[st_0_ref, idxInt(st_1_int) := st_2_int]
  Label20:
   sourceline 20
    (* LDC + INVOKESTATIC - Specification injection *)
    skip MARK, 2
  Label21:
   sourceline 9
    (* IINC *)
    _i := _i + 1
    (* GOTO *)
    goto Label2
  Label5:
   sourceline 22
    (* RETURN *)
    exc := null
    goto LabelEnd
  Label22:
  LabelEnd:
    assert exc = null ; "No exception has been thrown"
    skip ; "No frame specfied"
(* end of program *)


(* created : Sat Mar 16 14:01:45 CET 2013 - Alpha-3 *)
#
# This file was generated by PSEUDO
# which is copyright (C) 2009 Universitaet Karlsruhe, Germany
#    written by Mattias Ulbrich
#

include "$bytecode.p"
include "$intRange.p"
include "declarations.p"

(* program variables *)
function
   int _src assignable (* local variable '1' *)
   int pre_src assignable (* method parameter, prestate *)
   int _dest assignable (* method parameter / ... *)
   int pre_dest assignable (* method parameter, prestate *)
   ref st_0_ref assignable (* stack variable *)
   int st_0_int assignable (* stack variable *)
   ref _V assignable (* local variable '3' *)
   ref _C assignable (* local variable '4' *)
   ref _N assignable (* local variable '5' *)
   int st_1_int assignable (* stack variable *)
   bool st_2_bool assignable (* stack variable *)
   int st_2_int assignable (* stack variable *)
   bool st_0_bool assignable (* stack variable *)
   int _d assignable (* local variable '6' *)
   ref st_1_ref assignable (* stack variable *)
   bool branchCond assignable (* branching condition *)
   int _v assignable (* local variable '7' *)
   int _w assignable (* local variable '8' *)
   ref st_2_ref assignable (* stack variable *)

(* the translated Java program *)
program Java source "./BFS.jspec"
   sourceline 92
    assume !h[_this, F_BFS_adjacency] = null ; "Assume precondition"
   sourceline 93
    assume h[_this, F_BFS_size] > 0 ; "Assume precondition"
   sourceline 94
    assume arrlen(h[_this, F_BFS_adjacency]) = h[_this, F_BFS_size] ; "Assume precondition"
   sourceline 95
    assume (\forall i; 0<=i & i < h[_this, F_BFS_size] ->
                    !h[h[_this, F_BFS_adjacency], idxRef(i)] = null
                  &   arrlen(h[h[_this, F_BFS_adjacency], idxRef(i)]) 
                    = h[_this, F_BFS_size]) ; "Assume precondition"
   sourceline 99
    assume 0 <= _src & _src < h[_this, F_BFS_size] ; "Assume precondition"
   sourceline 100
    assume 0 <= _dest & _dest < h[_this, F_BFS_size] ; "Assume precondition"
    assume wellformed(h) ; "assumption guaranteed by Java"
    assume !_this = null ; "assumption guaranteed by Java"
    assume h[_this, created] ; "assumption guaranteed by Java"
    assume typeof(_this) = C_BFS ; "assumption of the runtime type"
    pre_h := h || pre_src := _src || pre_dest := _dest ; "Recording the prestate"
    decrBase := 1 ; "Save the decrease (variant) base"
  Label1:
   sourceline 107
    (* ALOAD *)
    st_0_ref := _this
    (* GETFIELD *)
    st_0_int := h[st_0_ref, F_BFS_size]
    (* NEWARRAY *)
    havoc new
    assume !h[new, created]
    assume arrlen(new) = st_0_int
    assume typeof(new) = array_boolean
    h := create(h, new)
    h := h[new, created := true]
    st_0_ref := new
    (* ASTORE *)
    _V := st_0_ref
  Label2:
   sourceline 108
    (* ALOAD *)
    st_0_ref := _this
    (* GETFIELD *)
    st_0_int := h[st_0_ref, F_BFS_size]
    (* NEWARRAY *)
    havoc new
    assume !h[new, created]
    assume arrlen(new) = st_0_int
    assume typeof(new) = array_boolean
    h := create(h, new)
    h := h[new, created := true]
    st_0_ref := new
    (* ASTORE *)
    _C := st_0_ref
  Label3:
   sourceline 109
    (* ALOAD *)
    st_0_ref := _this
    (* GETFIELD *)
    st_0_int := h[st_0_ref, F_BFS_size]
    (* NEWARRAY *)
    havoc new
    assume !h[new, created]
    assume arrlen(new) = st_0_int
    assume typeof(new) = array_boolean
    h := create(h, new)
    h := h[new, created := true]
    st_0_ref := new
    (* ASTORE *)
    _N := st_0_ref
  Label4:
   sourceline 111
    (* LDC + INVOKESTATIC - Specification injection *)
  Label5:
   sourceline 112
    (* LDC + INVOKESTATIC - Specification injection *)
  Label6:
   sourceline 113
    (* LDC + INVOKESTATIC - Specification injection *)
  Label7:
   sourceline 115
    (* ALOAD *)
    st_0_ref := _V
    (* ILOAD *)
    st_1_int := _src
    (* ICONST_1 *)
    st_2_bool := true
    st_2_int := 1
    (* BASTORE *)
    h := h[st_0_ref, idxBool(st_1_int) := st_2_bool]
  Label8:
   sourceline 116
    (* ALOAD *)
    st_0_ref := _C
    (* ILOAD *)
    st_1_int := _src
    (* ICONST_1 *)
    st_2_bool := true
    st_2_int := 1
    (* BASTORE *)
    h := h[st_0_ref, idxBool(st_1_int) := st_2_bool]
  Label9:
   sourceline 117
    (* ICONST_0 *)
    st_0_bool := false
    st_0_int := 0
    (* ISTORE *)
    _d := st_0_int
  Label10:
   sourceline 119
    (* LDC + INVOKESTATIC - Specification injection *)
  Label11:
   sourceline 123
    (* ALOAD *)
    st_0_ref := _this
    (* ALOAD *)
    st_1_ref := _C
    (* INVOKEVIRTUAL *)
    havoc resBool
    st_0_bool := resBool
    ho := h
    havoc h
    assume wellformed(h)
    skip (* unsupported emptyset *)
    assume modHeap(h, ho, {h:=ho}(emptyset))
    assume resBool = !(\exists i; 0 <= i & i < arrlen(st_1_ref) & 
                                  h[st_1_ref, idxBool(i)]) ; "postcondition for BFS.isEmpty"
    (* IFNE *)
    branchCond := st_0_bool
    goto Label12, Label13
  Label12:
    assume branchCond
    goto Label14
  Label13:
    assume !branchCond
  Label15:
   sourceline 124
    (* LDC + INVOKESTATIC - Specification injection *)
    skip MARK, 1
  Label16:
   sourceline 125
    (* ALOAD *)
    st_0_ref := _this
    (* ALOAD *)
    st_1_ref := _C
    (* ICONST_0 *)
    st_2_bool := false
    st_2_int := 0
    (* INVOKEVIRTUAL *)
    havoc resInt
    st_0_int := resInt
    ho := h
    havoc h
    assume wellformed(h)
    skip (* unsupported emptyset *)
    assume modHeap(h, ho, {h:=ho}(emptyset))
    assume -1 = resInt | st_2_int <= resInt & resInt < arrlen(st_1_ref) ; "postcondition for BFS.first"
    assume resInt >= st_2_int -> h[st_1_ref, idxBool(resInt)] &
                     (\forall i; st_2_int<=i & i<resInt -> !h[st_1_ref, idxBool(i)]) ; "postcondition for BFS.first"
    assume resInt = -1 -> (\forall i; 0<=i & i<arrlen(st_1_ref) -> 
                                  !h[st_1_ref,idxBool(i)]) ; "postcondition for BFS.first"
    (* ISTORE *)
    _v := st_0_int
  Label17:
   sourceline 128
    (* LDC + INVOKESTATIC - Specification injection *)
  Label18:
   sourceline 129
    (* ALOAD *)
    st_0_ref := _C
    (* ILOAD *)
    st_1_int := _v
    (* ICONST_0 *)
    st_2_bool := false
    st_2_int := 0
    (* BASTORE *)
    h := h[st_0_ref, idxBool(st_1_int) := st_2_bool]
  Label19:
   sourceline 130
    (* ILOAD *)
    st_0_int := _v
    (* ILOAD *)
    st_1_int := _dest
    (* IF_ICMPNE *)
    branchCond := !st_0_int = st_1_int
    goto Label20, Label21
  Label20:
    assume branchCond
    goto Label22
  Label21:
    assume !branchCond
  Label23:
   sourceline 131
    (* ILOAD *)
    st_0_int := _d
    (* IRETURN *)
    exc := null
    resInt := st_0_int
    goto LabelEnd
  Label22:
   sourceline 134
    (* LDC + INVOKESTATIC - Specification injection *)
  Label24:
   sourceline 139
    (* LDC + INVOKESTATIC - Specification injection *)
    skip MARK, 2
  Label25:
   sourceline 140
    (* ICONST_0 *)
    st_0_bool := false
    st_0_int := 0
    (* ISTORE *)
    _w := st_0_int
  Label26:
   sourceline 143
    (* ALOAD *)
    st_0_ref := _this
    (* ALOAD *)
    st_1_ref := _this
    (* GETFIELD *)
    st_1_ref := h[st_1_ref, F_BFS_adjacency]
    (* ILOAD *)
    st_2_int := _v
    (* AALOAD *)
    st_1_ref := h[st_1_ref, idxRef(st_2_int)] ; "read value from array"
    (* ILOAD *)
    st_2_int := _w
    (* INVOKEVIRTUAL *)
    havoc resInt
    st_0_int := resInt
    ho := h
    havoc h
    assume wellformed(h)
    skip (* unsupported emptyset *)
    assume modHeap(h, ho, {h:=ho}(emptyset))
    assume -1 = resInt | st_2_int <= resInt & resInt < arrlen(st_1_ref) ; "postcondition for BFS.first"
    assume resInt >= st_2_int -> h[st_1_ref, idxBool(resInt)] &
                     (\forall i; st_2_int<=i & i<resInt -> !h[st_1_ref, idxBool(i)]) ; "postcondition for BFS.first"
    assume resInt = -1 -> (\forall i; 0<=i & i<arrlen(st_1_ref) -> 
                                  !h[st_1_ref,idxBool(i)]) ; "postcondition for BFS.first"
    (* ISTORE *)
    _w := st_0_int
  Label27:
   sourceline 145
    (* ILOAD *)
    st_0_int := _w
    (* ICONST_M1 *)
    st_1_int := -1
    (* IF_ICMPNE *)
    branchCond := !st_0_int = st_1_int
    goto Label28, Label29
  Label28:
    assume branchCond
    goto Label30
  Label29:
    assume !branchCond
  Label31:
   sourceline 146
    (* GOTO *)
    goto Label32
  Label30:
   sourceline 148
    (* LDC + INVOKESTATIC - Specification injection *)
    skip MARK, 3
  Label33:
   sourceline 149
    (* ILOAD *)
    st_0_int := _w
    (* ALOAD *)
    st_1_ref := _this
    (* GETFIELD *)
    st_1_int := h[st_1_ref, F_BFS_size]
    (* IF_ICMPGE *)
    branchCond := st_0_int >= st_1_int
    goto Label34, Label35
  Label34:
    assume branchCond
    goto Label36
  Label35:
    assume !branchCond
    (* ALOAD *)
    st_0_ref := _V
    (* ILOAD *)
    st_1_int := _w
    (* BALOAD *)
    st_0_bool := h[st_0_ref, idxBool(st_1_int)] ; "read value from array"
    (* IFNE *)
    branchCond := st_0_bool
    goto Label37, Label38
  Label37:
    assume branchCond
    goto Label36
  Label38:
    assume !branchCond
  Label39:
   sourceline 150
    (* ALOAD *)
    st_0_ref := _V
    (* ILOAD *)
    st_1_int := _w
    (* ICONST_1 *)
    st_2_bool := true
    st_2_int := 1
    (* BASTORE *)
    h := h[st_0_ref, idxBool(st_1_int) := st_2_bool]
  Label40:
   sourceline 151
    (* ALOAD *)
    st_0_ref := _N
    (* ILOAD *)
    st_1_int := _w
    (* ICONST_1 *)
    st_2_bool := true
    st_2_int := 1
    (* BASTORE *)
    h := h[st_0_ref, idxBool(st_1_int) := st_2_bool]
  Label36:
   sourceline 154
    (* LDC + INVOKESTATIC - Specification injection *)
    skip MARK, 4
  Label41:
   sourceline 155
    (* IINC *)
    _w := _w + 1
    (* GOTO *)
    goto Label26
  Label32:
   sourceline 157
    (* LDC + INVOKESTATIC - Specification injection *)
    skip MARK, 5
  Label42:
   sourceline 158
    (* ALOAD *)
    st_0_ref := _this
    (* ALOAD *)
    st_1_ref := _C
    (* INVOKEVIRTUAL *)
    havoc resBool
    st_0_bool := resBool
    ho := h
    havoc h
    assume wellformed(h)
    skip (* unsupported emptyset *)
    assume modHeap(h, ho, {h:=ho}(emptyset))
    assume resBool = !(\exists i; 0 <= i & i < arrlen(st_1_ref) & 
                                  h[st_1_ref, idxBool(i)]) ; "postcondition for BFS.isEmpty"
    (* IFEQ *)
    branchCond := !st_0_bool
    goto Label43, Label44
  Label43:
    assume branchCond
    goto Label45
  Label44:
    assume !branchCond
  Label46:
   sourceline 159
    (* ALOAD *)
    st_0_ref := _this
    (* ALOAD *)
    st_1_ref := _C
    (* ALOAD *)
    st_2_ref := _N
    (* INVOKEVIRTUAL *)
    ho := h
    havoc h
    assume wellformed(h)
    skip (* unsupported singleton(target) *)
    assume modHeap(h, ho, {h:=ho}(singleton(st_1_ref)))
    assume (\forall i; 0 <= i & i < arrlen(st_1_ref) -> 
           h[st_1_ref, idxBool(i)] = h[st_2_ref, idxBool(i)]) ; "postcondition for BFS.copy"
  Label47:
   sourceline 160
    (* ALOAD *)
    st_0_ref := _this
    (* ALOAD *)
    st_1_ref := _N
    (* INVOKEVIRTUAL *)
    ho := h
    havoc h
    assume wellformed(h)
    skip (* unsupported singleton(array) *)
    assume modHeap(h, ho, {h:=ho}(singleton(st_1_ref)))
    assume (\forall i; 0 <= i & i < arrlen(st_1_ref) -> 
                                  !h[st_1_ref, idxBool(i)]) ; "postcondition for BFS.clear"
  Label48:
   sourceline 161
    (* IINC *)
    _d := _d + 1
  Label45:
   sourceline 164
    (* LDC + INVOKESTATIC - Specification injection *)
    skip MARK, 6
  Label49:
   sourceline 165
    (* GOTO *)
    goto Label11
  Label14:
   sourceline 167
    (* ICONST_M1 *)
    st_0_int := -1
    (* IRETURN *)
    exc := null
    resInt := st_0_int
    goto LabelEnd
  Label50:
  LabelEnd:
(* end of program *)


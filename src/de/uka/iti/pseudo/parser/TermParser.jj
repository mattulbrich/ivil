
options {
        STATIC = false;
}

PARSER_BEGIN(FormulaParser)
package de.uka.ilkd.tablet;

import java.util.*;

public class TermParser {

  // TODO to be moved elsewhere, but keep a (non-static) reference here
  static HashMap<String, InfixOperator> infixTable = new HashMap<String, InfixOperator>();
  
  // likewise prefix
  
  static {
     infixTable.put("+", new InfixOperator("+", "$add", 50));
  }

  ASTTerm shuntingYard(int prec) throws ParserException {
     Stack<Pair<Token, InfixOperator>> opStack;
     Stack<Term> termStack;
     
     loop: while(true) {

        Token token = getToken(1);

        InfixOperator infixOp;

        switch(token.kind) {
        case IDENTIFIER:
          infixOp = infixTable.get(token.image);
          if(infixOp == null) {
              termStack.push(ApplicationTerm());
              continue loop;
          }
          break;
          
        case OPIDENTIFIER:
          infixOp = infixTable.get(token.image);
          if(infixOp == null) {
              throw new ParserException("think up something");
          }
          break;
          
        case NUMBERLITERAL:
          termStack.push(NumberLiteral());
          break;
          
        default:
          break loop;
        }
        
        assert infixOp != null;
          
        if(opStack.empty() || opStack.peek().snd().getPrecedence() > infixOp.getPrecedence()) {
           opStack.push(new Pair<Token, InfixOperator>(token, infixOp));
        } else {
           if(termStack.size() < 2) { 
              throw new ParserException();
           }
           ASTTerm t2 = termStack.pop();
           ASTTerm t1 = termStack.pop();
           ASTTerm result = new ASTInfixTerm(token, infixOp, t1, t2);
           termStack.push(result);
       }
       
       getNextToken();
       
    }
  
    while(termStack.size() >= 2) {
       assert !opStack.empty();
       Pair tokenAndOp = opStack.pop();
       ASTTerm t2 = termStack.pop();
       ASTTerm t1 = termStack.pop();
       ASTTerm result = new ASTInfixTerm(tokenAndOp, t1, t2);
       termStack.push(result);
    }
    
    if(termStack.empty() != 1 || !opStack().empty()) {
       throw new ParserException();
    }
    
    return termStack.pop();
  }

}

PARSER_END(FormulaParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{

// Logics
| < LEFTPAREN: "(" >
| < RIGHTPAREN: ")" >
| < COMMA: "," >
| < SEMICOLON: ";" >
| < DOT: "." >
| < OR: "|" >
| < NOT: "~" >
| < IMPLIES: "->" >
| < EQUIV: "<->" >
| < EQUALS: "=" >  
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >

// Programs
| < WHILE: "while" >
| < WHILE: "do" >
| < END: "end" >
| < ASSIGN: ":=" >

// Identifiers
| < BINDERIDENTIFIER: "\\" <IDENTIFIER> >
| < TYVARIDENTIFIER: "'" <IDENTIFIER> >
| < IDENTIFIER: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","0"-"9","_","'"] )* >
| < OPIDENTIFIER: ( ["+","-","<",">","&","|","=","*","/"] )+ >

| < OTHER: ["\u0000"-"\uFFFF"] >

}

ASTTerm Term():
{ ASTTerm term;}
{
        (
          LOOKAHEAD( GeneralIdentifier() ) term = PrecedenceTerm()
        | AtomicTerm() 
        )
   { return term; }
}

ASTTerm AtomicTerm():
{ ASTTerm term; }
{
        ( LOOKAHEAD(2) "(" term=BinderTerm() ")"
        | LOOKAHEAD(2) "(" term=Term() ")"
        | term=ApplicationTerm()
        | term=ModalityTerm()
        | "(" term=IfThenElseTerm() ")"
        ) { return term; }
}

ASTBinderTerm BinderTerm():
{
  Token binderToken;
  Token varToken;
  ASTTypeRef type; 
  ASTTerm t;
  List<ASTTerm> subterms = new ArrayList<ASTTerm>(); 
}
{
        binderToken = <BINDERIDENTIFIER>
        type = TypeRef();
        varToken = <IDENTIFIER>
        ( ";" t=Term() { subterms.add(t); } )+
   { return new ASTBinderTerm(binderToken, type, varToken, subterms); }
}

ASTIfThenElseTerm BinderTerm():
{
  ASTTerm condTerm, thenTerm, elseTerm; 
}
{
        "if"
        condTerm = Term();
        "then"
        thenTerm = Term();
        "else"
        elseTerm = Term();
   { return new ASTIfThenElseTerm(condTerm, thenTerm, elseTerm); }
}  
        
ASTApplicationTerm ApplicationTerm():
{
  Token symbol;
  List<ASTTerm> subterms = new ArrayList<ASTTerm>();
}
{
        symbol = <IDENTIFIER>
        
        ( /* parentheses are not empty, constants dont have them */ 
          "("
          t = Term() { subterms.add(t); }
          ( "," t = Term() { subterms.add(t); } )*
        )?
        
    { return new ASTApplicationTerm(symbol, subterms); }
}

Token GeneralIdentifier():
{ 
  Token t;
}
{
        (t=<IDENTIFIER> | t=<OPIDENTIFIER) 
  { return getToken(); }
}

ASTNumberLiteralTerm NumberLiteral():
{
  Token t;
}
{
        t=<NUMBERLITERAL>
  { return new ASTNumberLiteralTerm(t); }
}

ASTModalityTerm ModalityTerm():
{
  ASTModality modality;
  ASTTerm term;
}
{
        modality = Modality();
        term = Term();
  { return new ASTModalityTerm(modality, term); }
}

ASTModality Modality():
{
  ASTTerm term, term2, term3;
  ASTModality mod;
  Token id;
}
{
          id=<IDENTIFIER> ":=" term=Term()
            { return new ASTModAssignment(id, term); }
        | "while" term=Term() "do" mod=Modality() "end"
            { return new ASTModWhile(term, mod); }
        | "if" term=Term() "then" term2=Term() "else" term3=Term()
            { return new ASTModIf(term, term2, term3); }
}

JAVACODE ASTTerm PrecedenceTerm() {
    return precedenceClimbing(0);
}





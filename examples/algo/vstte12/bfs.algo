uses "bfs.algo.p"

algo bfs
input
   src, dest : vertex
output
   d : int
var
   size : int
   V, C, N : set(vertex)
   Vo, Co, No : set(vertex)
   tovisit : set(vertex)
   v,w : vertex
   
requires 
   finite(fullset as set(vertex))

ensures
   d >= -1
   
ensures
   d < 0 -> (\forall m; m >= 0 -> not minconnect(src,dest,m))
   
ensures
   d >= 0 -> minconnect(src, dest, d) 

do
   size := card(fullset as set(vertex));
   
   V := {src};
   C := {src};
   N := {};
   d := 0;
   done := {};
   while !(C = {})
     inv 
       d >= 0 &
       (\forall x; x in C -> minconnect(src, x, d)) &
       (\forall y; y in N -> minconnect(src, y, d+1)) &
       (\forall z; z in V \ N <->
           (\exists n; 0 <= n <= d & minconnect(src, z, n))) &
       (\forall a; minconnect(src, a, d+1) ->
           (\exists b; a in succ(b) & b in C) | a in N) &
       (C = {} -> N = {}) &
       C <: V &
       N <: V &
       not dest in (V \ N) \ C &
       done /\ C = emptyset
     var ^done
   do
     choose v such that v in C;
     C := C \ {v};
     done := done \/ {v};
     if v = dest 
     then 
       return
     end;
     
     Vo := V;
     No := N;
     iterate succ(v) with w as tovisit
       inv tovisit <: succ(v) &
           V = Vo \/ (succ(v) \ tovisit) &
           N = No \/ (succ(v) \ (V \/ tovisit))
     do 
       if not w in V
       then
         V := V \/ {w};
         N := N \/ {w}
       end
     end;
     
     if C = {}
     then
       C := N;
       N := {};
       d := d+1
     end
   end;

   note (\forall a; not minconnect(src, a, d+1));
      
   
   
   note (\forall i; i>=0 -> (\forall a; !minconnect(src, a, d+1+i))) 
      with "ยง(rule int_induction_match)";

   d := -1
end 


options {
        STATIC = false;
}

PARSER_BEGIN(TermParser)
package de.uka.iti.pseudo.parser.term;

import java.util.*;
import java.io.*;
import de.uka.iti.pseudo.environment.InfixOperator;
import de.uka.iti.pseudo.util.Pair;

public class TermParser {

    private String fileName;

    public TermParser(String string, String fileName, int line, int col) {
        this(new StringReader(string));
        this.fileName = fileName;
        jj_input_stream.line = line;
        jj_input_stream.column = col - 1;
    }
    
    public ASTTerm parseTerm() throws ParseException 
    {
    	ASTTerm term = Term();
    	term.setFilename(fileName);
    	return term;
    }
  
    /* to be used elsewhere!
    ASTTerm shuntingYard(int prec) throws ParseException {
        Stack<Pair<Token, InfixOperator>> opStack =
            new Stack<Pair<Token, InfixOperator>>();
        Stack<ASTTerm> termStack =
            new Stack<ASTTerm>();

        loop: while (true) {

            Token token = getToken(1);

            InfixOperator infixOp = null;

            switch (token.kind) {
            case IDENTIFIER:
                infixOp = infixTable.get(token.image);
                if (infixOp == null) {
                    termStack.push(ApplicationTerm());
                    continue loop;
                }
                break;

            case OPIDENTIFIER:
                infixOp = infixTable.get(token.image);
                if (infixOp == null) {
                    throw new ParseException("think up something");
                }
                break;

            case NUMBERLITERAL:
                termStack.push(NumberLiteral());
                break;

            default:
                break loop;
            }

            assert infixOp != null;

            if (opStack.empty()
                    || opStack.peek().snd().getPrecedence() > infixOp
                            .getPrecedence()) {
                opStack.push(new Pair<Token, InfixOperator>(token, infixOp));
            } else {
                if (termStack.size() < 2) {
                    throw new ParseException();
                }
                ASTTerm t2 = termStack.pop();
                ASTTerm t1 = termStack.pop();
                ASTTerm result = null; // new ASTInfixTerm(token, infixOp, t1, t2);
                termStack.push(result);
            }

            getNextToken();

        }

        while (termStack.size() >= 2) {
            assert !opStack.empty();
            Pair<Token, InfixOperator> tokenAndOp = opStack.pop();
            ASTTerm t2 = termStack.pop();
            ASTTerm t1 = termStack.pop();
            ASTTerm result = null; // new ASTInfixTerm(tokenAndOp, t1, t2);
            termStack.push(result);
        }

        if (termStack.size() != 1 || !opStack.empty()) {
            throw new ParseException();
        }

        return termStack.pop();
    }*/
}

PARSER_END(TermParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{

// Logics
  < LEFTPAREN: "(" >
| < RIGHTPAREN: ")" >
| < LEFTSQUARE: "[" >
| < RIGHTSQUARE: "]" >
| < COMMA: "," >
| < SEMICOLON: ";" >
| < DOT: "." >
| < OR: "|" >
| < NOT: "~" >
| < IMPLIES: "->" >
| < EQUIV: "<->" >
| < EQUALS: "=" >  

// Programs
| < _SKIP: "skip" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < DO: "do" >
| < END: "end" >
| < ASSIGN: ":=" >

// Identifiers
| < BINDERIDENTIFIER: "\\" <IDENTIFIER> >
| < TYVARIDENTIFIER: "'" <IDENTIFIER> >
| < IDENTIFIER: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","0"-"9","_","'"] )* >
| < OPIDENTIFIER: ( ["+","-","<",">","&","|","=","*","/"] )+ >

// Literals
| < NUMBERLITERAL: ( ["0" - "9"] )+ >

}

ASTTerm Term():
{ 
  ASTTerm term;
  List<ASTTerm> list = new ArrayList<ASTTerm>(); 
}
{
        term=BaseTerm() { list.add(term); }
        (
          term=GeneralIdentifier() { list.add(term); }
          term=BaseTerm() { list.add(term); }
        )*
   { 
     if(list.size() > 1)
        return new ASTListTerm(list);
     else
        return list.get(0);
   }
}

ASTTerm BaseTerm():
{ ASTTerm term; }
{
        ( LOOKAHEAD(2) "(" term=BinderTerm() ")"
        | "(" term=Term() ")"
        | term=ApplicationTerm()
        | term=NumberLiteral()
        | term=ModalityTerm()
        ) { return term; }
}

ASTBinderTerm BinderTerm():
{
  Token binderToken;
  Token varToken;
  ASTTypeRef type; 
  ASTTerm t;
  List<ASTTerm> subterms = new ArrayList<ASTTerm>(); 
}
{
        binderToken = <BINDERIDENTIFIER>
        type = TypeRef()
        varToken = <IDENTIFIER>
        ( ";" t=Term() { subterms.add(t); } )+
   { return new ASTBinderTerm(binderToken, type, varToken, subterms); }
}

ASTTypeRef TypeRef():
{
  Token token;
  List<ASTTypeRef> args = new ArrayList<ASTTypeRef>();
  ASTTypeRef ty;
}
{
		token = <IDENTIFIER>
		(
		  "(" ty=TypeRef() { args.add(ty); }
		  		( "," ty=TypeRef() { args.add(ty); } )*
		  ")"
		)?
		{ return new ASTTypeRef(token, args); }
}


/*
ASTIfThenElseTerm IfThenElseTerm():
{
  ASTTerm condTerm, thenTerm, elseTerm; 
}
{
        "if"
        condTerm=Term()
        "then"
        thenTerm=Term()
        "else"
        elseTerm=Term()
   { return new ASTIfThenElseTerm(condTerm, thenTerm, elseTerm); }
}
*/ 
        
ASTTerm ApplicationTerm():
{
  Token symbol;
  ASTTerm t;
  List<ASTTerm> subterms = new ArrayList<ASTTerm>();
}
{
        symbol=<IDENTIFIER>
        
        ( /* parentheses are not empty, constants dont have them */ 
          "("
          t=Term() { subterms.add(t); }
          ( "," t=Term() { subterms.add(t); } )*
          ")"
        )?
        
    { if(subterms.size() > 0) 
        return new ASTApplicationTerm(symbol, subterms); 
      else
        return new ASTIdentifierTerm(symbol);
    }
}

ASTTerm GeneralIdentifier():
{ 
  Token t;
}
{
        (t=<IDENTIFIER> | t=<OPIDENTIFIER>) 
  { return new ASTIdentifierTerm(t); }
}

ASTNumberLiteralTerm NumberLiteral():
{
  Token t;
}
{
        t=<NUMBERLITERAL>
  { return new ASTNumberLiteralTerm(t); }
}

ASTModalityTerm ModalityTerm():
{
  ASTModality modality;
  ASTTerm term;
}
{
        "[" modality=ModalityList() "]"
        term=BaseTerm() 
  { return new ASTModalityTerm(modality, term); }
}

ASTModality ModalityList():
{
  ASTModality mod, mod2;
}
{
  mod=Modality()
  (
    ";"
    mod2=ModalityList()
      { mod = new ASTModCompound(mod, mod2); }
  )?
  { return mod; }
}

ASTModality Modality():
{
  ASTTerm term, term2, term3;
  ASTModality mod, mod2 = null;
  Token id;
  Token t;
}
{
          id=<IDENTIFIER> ":=" term=Term()
            { return new ASTModAssignment(id, term); }
        | t="while" term=Term() "do" mod=ModalityList() "end"
            { return new ASTModWhile(t,term, mod); }
        | t="if" term=Term() "then" mod=ModalityList() 
            ( "else" mod2=ModalityList() )? "end"
            { return new ASTModIf(t, term, mod, mod2); }
        | t="skip"
            { return new ASTModSkip(t); }
}
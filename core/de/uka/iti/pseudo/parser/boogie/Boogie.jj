
options {
    STATIC = false;
    UNICODE_INPUT = true;
    JAVA_UNICODE_ESCAPE = true;
}

/*---------------------------------------------------------------------------
// BoogiePL -
//--------------------------------------------------------------------------*/


PARSER_BEGIN(Parser)
package de.uka.iti.pseudo.parser.boogie;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.util.LinkedList;
import java.util.List;

import de.uka.iti.pseudo.parser.boogie.ast.*;

// we dont want warnings here, as the code is created by a generator
@SuppressWarnings("all")
public class Parser {

public CompilationUnit parseFile(File file) throws FileNotFoundException, ParseException {
       return parseFile(new FileReader(file), file.getPath());
    }
    
    public CompilationUnit parseURL(URL url) throws ParseException, IOException {
        Reader reader = new InputStreamReader(url.openStream());
        return parseFile(reader, url.toString());
     }
    
    public CompilationUnit parseFile(Reader reader, String filename) throws ParseException {
        ReInit(reader);
        CompilationUnit result = BoogiePL();
        result.setFilename(filename);
        return result;
    }

    public static void main(String args[]) throws FileNotFoundException, ParseException {
        Parser p = new Parser(new FileInputStream(args[0]));
        p.BoogiePL();
    }
}

PARSER_END(Parser)

TOKEN : {
  < #LETTER : ["A" - "Z", "a" - "z"] >
| < #DIGIT : ["0" - "9"] >
| < #SPECIAL : ["'", "~", "#", "$", "^", "_", ".", "?", "`"] >
| < #GLYPH : ["`", "~", "!", "@", "#", "$", "%", "^", "&", "*", 
              "(", ")", "-", "_", "=", "+", "[", "{", "]", "}", 
          "|", ";", ":", "'", ",", "<", ".", ">", "/", "?", 
          "\\"] >
| < #NONDIGIT : (<LETTER> | <SPECIAL>) >
}

/* Skip whitespace */
SKIP : { " " | "\t" | "\n" | "\r" }


/* Comments */
// TODO NESTING
SKIP :
{
  < SINGLE_LINE_COMMENT: "//" ( ~["\n", "\r"] )* >
| < MULTI_LINE_COMMENT: "/*" ( ~["*"] | ( ( "*" )+ ~["*", "/"] ) )* "*/" >
}

/* Reserved words */
TOKEN : {
  < VAR: "var">
| < WHERE: "where">
| < INT: "int">
| < BOOL: "bool">
| < BVTYPE: "bv" ( <DIGIT> )+ >
| < CONST: "const">
| < UNIQUE: "unique">
| < EXTENDS: "extends">
| < COMPLETE: "complete">
| < FUNCTION: "function">
| < RETURNS: "returns">
//| < INLINE: "inline">   seems not to be a keyword anymore
| < AXIOM: "axiom">
| < TYPE: "type">
| < PROCEDURE: "procedure">
| < IMPLEMENTATION: "implementation">
| < MODIFIES: "modifies">
| < FREE: "free">
| < REQUIRES: "requires">
| < ENSURES: "ensures">
| < GOTO: "goto">
| < RETURN: "return">
| < IF: "if">
| < THEN: "then" >
| < ELSE: "else">
| < WHILE: "while">
| < INVARIANT: "invariant">
| < BREAK: "break">
| < ASSERT: "assert">
| < ASSUME: "assume">
| < HAVOC: "havoc">
| < CALL: "call">
| < FALSE: "false">
| < TRUE: "true">
| < OLD: "old">
}


/* Operators */
// TODO check operators for completeness and unicode escapes
TOKEN: {
  < OP_ASSIGN: ":=" >
| < OP_MUL: "*" >
| < OP_FORALL: "forall" | "\u2200" >
| < OP_EXISTS: "exists" | "\u2203" >
| < OP_LAMBDA: "lambda" | "\u03bb" >
| < OP_SEP: "::" | "\u2022" >
}

/* Separators */
TOKEN: {
  < SEP_RCURLY: "}" >
| < SEP_LCURLY: "{" >
| < SEP_RBRACKET: "]" >
| < SEP_LBRACKET: "[" >
}

/* Literals / Identifiers*/
TOKEN: {
  < IDENT: ("\\")? <NONDIGIT> ( <NONDIGIT> | <DIGIT> )* >
| < BVLIT: ( <DIGIT> )+ "b" "v" ( <DIGIT> )+ >
| < STRING: "\"" ( ~["\"","\\","\n","\r"] )* "\"" >
| < FLOAT: ( <DIGIT> )+ "." ( <DIGIT> )+ > 
| < INTEGER : ( <DIGIT> )+ >
}

/*---------------------------------------------------------------------------
// BoogiePL -
//--------------------------------------------------------------------------*/

/*------------------------------------------------------------------------*/
CompilationUnit BoogiePL()
:{
    DeclarationBlock block=null;
    List<DeclarationBlock> declarations = new LinkedList<DeclarationBlock>();
} { 
  (
      ( block=Consts()             
      | block=Function()           
      | block=Axiom()              
      | block=UserDefinedTypes()   
      | block=GlobalVars()         
      | Procedure()  
      | Implementation()   
      ){if(null!=block)declarations.add(block);}
  )*
  <EOF>
  { return new CompilationUnit(declarations); } 
}

/*------------------------------------------------------------------------*/
GlobalVariableDeclaration GlobalVars()
:{
    Token first;
    List<Attribute> attr;
    List<Variable> vars;
} { 
  first="var"  attr=AttributeList()
  
  vars=IdsTypeWheres(false) ";"
  
  { return new GlobalVariableDeclaration(first, attr, vars); }
}

void LocalVars()
:{} { 
  "var"
  ( Attribute() )*
  IdsTypeWheres(false) ";"
  
}

void ProcFormals()
:{} { 
  "("
  ( IdsTypeWheres(false) )?
  ")"
  
}

void BoundVars()
:{} { 
  IdsTypeWheres(false)
  
}

/*------------------------------------------------------------------------*/
/* IdsType is used with const declarations */
List<Variable> IdsType(boolean isConstant)
:{
    List<Token> names;
    Type t;
} { 
  names=Idents() ":" t=Type()
  {
    List<Variable> rval = new LinkedList<Variable>();
    for(Token name : names)
        rval.add(new Variable(name, t, isConstant, null));
        
    return rval; 
  }
}

/* IdsTypeWheres is used with the declarations of global and local variables,
   procedure parameters, and quantifier bound variables. */
List<Variable> IdsTypeWheres(boolean isConstant)
:{
    List<Variable> rval,tmp;
} {
  rval=IdsTypeWhere(isConstant)
  ( "," tmp=IdsTypeWhere(isConstant) {rval.addAll(tmp);} )*
  
  { return rval; }
}

List<Variable> IdsTypeWhere(boolean isConstant)
:{
    List<Token> names;
    Type t;
    Expression e = null;
} { 
  names=Idents() ":" t=Type()
  ( "where" e=Expression()  
  )?
  
  {
    List<Variable> rval = new LinkedList<Variable>();
    for(Token name : names)
        rval.add(new Variable(name, t, isConstant, e));
        
    return rval; 
  }
}

/*------------------------------------------------------------------------*/
Type Type()
:{
    Type t;
} { 
  ( t=TypeAtom()
  | (
    {
        Token name;
        //types needs initialization because TypeArgs is optional
        List<Type> types = new LinkedList<Type>();
    }
    name=<IDENT>       
    ( types=TypeArgs() )?
    { return new TemplateType(name, types); }
    )   
  | t=MapType()
  )
  { return t; }
}

List<Type> TypeArgs()
:{
    Type t;
    List<Type> rval = new LinkedList<Type>(), tmp;
} { 
  (
    t=TypeAtom() { rval.add(t); }     
    ( tmp=TypeArgs() {rval.addAll(tmp);} )?
  |
    // this is to be interpreted as an TemplateType without arguments
    { Token name; }
    name=<IDENT> {
        rval.add(new TemplateType(name, new LinkedList<Type>()));
    }      
    ( tmp=TypeArgs() {rval.addAll(tmp);} )?
  |
    t=MapType() {rval.add(t);}
  )
  
  { return rval; }
}

Type TypeAtom()
:{
    Token t;
    Type rval;
} { 
  (( t="int"
  | t="bool"
  | t=<BVTYPE>
  ) { return new BuiltInType(t); }
  | "(" rval=Type() ")" {return rval;}
  )
}

MapType MapType()
:{
    Token first=null,tmp;
    List<Token> params = new LinkedList<Token>();
    List<Type> domain = new LinkedList<Type>();
    Type range;
} { 
  ( 
  first="<"
    params=Idents()
  ">"
  )?
  tmp="[" {if(null==first)first=tmp;}                                 
    ( domain=Types() )?
  "]"
  range=Type()
 
  {return new MapType(first, params, domain, range);}
}

List<Token> TypeParams()
:{
    List<Token> L;
} { 
  "<"    
    L=Idents()
  ">"
  {return L;}
  
}

List<Type> Types()
:{
    Type t;
    List<Type> types = new LinkedList<Type>();
} { 
  t=Type() { types.add(t); }
  ( "," t=Type() { types.add(t); }
  )*
  {return types;}
}


/*------------------------------------------------------------------------*/
ConstantDeclaration Consts() 
:{
    Token first;
    List<Attribute> attributes;
    Boolean unique = false;
    List<Variable> varnames;
    //todo order specification
} { 
  first = "const"
  attributes = AttributeList()
  ( "unique" {unique = true;}
  )?
  varnames = IdsType(true)
  ( OrderSpec() )?
  
  ";"
  { return new ConstantDeclaration(first, attributes, unique, varnames); }
}

// TODO implement later as explained in Boogie 2 Manual Chapter 10. It should be relatively easy to create the implied axioms.
void OrderSpec()
:{} { 
  "extends"                
  (
    ( "unique"             
    )?
    <IDENT>    
    (
      ","                  
      ( "unique"           
      )?
      <IDENT>    
    )*
  )?
  ( "complete"             
  )?
}

/*------------------------------------------------------------------------*/


FunctionDeclaration Function()
:{
    Token first;
    List<Attribute> attributes;
    Token name;
    // TODO add signotaure treatment
    Expression expression=null;
} { 
  first="function" attributes=AttributeList() name=<IDENT> 
  ( TypeParams() )?
  
  "("
      ( VarOrType()      
        ( "," VarOrType())* 
      )?
  ")"
  
  ( 
    "returns" "(" VarOrType() ")" 
    | 
    ":" Type()    
  )
  
  ( "{" expression=Expression()  "}" | ";" )
  
  { return new FunctionDeclaration(first, attributes, name, expression); }
}

void VarOrType()
:{} { 
  Type()    
  ( ":"           
    Type()
  )?
  
}

/*------------------------------------------------------------------------*/
AxiomDeclaration Axiom()
:{
    Token first;
    List<Attribute> attributes;
    Expression axiom;
} { 
  (first = "axiom"
    attributes=AttributeList()
   
  axiom = Expression() ";")
  { return new AxiomDeclaration(first, attributes, axiom); }
}

/*------------------------------------------------------------------------*/
UserDefinedTypeDeclaration UserDefinedTypes()
:{
    Token first;
    List<Attribute> attr;
    List<UserTypeDefinition> typedefs = new LinkedList<UserTypeDefinition>();
    UserTypeDefinition t;
} { 
  first="type"
  attr=AttributeList()
  t=UserDefinedType() {typedefs.add(t);}          
  ( "," t=UserDefinedType() {typedefs.add(t);} )*
  ";"
  
  { return new UserDefinedTypeDeclaration(first, attr, typedefs); }
}

UserTypeDefinition UserDefinedType()
:{
    Token name;
    List<String> argnames = new LinkedList<String>();
    Type parent = null;
} { 
  name=<IDENT>
  ( argnames=WhiteSpaceIdents() )?
  (
    "=" parent=Type()
    
  )?
  
  { return new UserTypeDefinition(name, argnames, parent); }
}


/*------------------------------------------------------------------------*/
void Procedure()
:{} { 

  "procedure"
  ProcSignature()
  ( (";")?
    (Spec())*
    (ImplBody())?
  )
  
}


void Implementation()
:{} { 

  "implementation"
  ProcSignature()
  ImplBody()
    
}


void ProcSignature()
:{} { 
  ( Attribute() )*
  <IDENT>
  ( TypeParams() )?
  ProcFormals()
  ( "returns" ProcFormals() )?
}


void Spec()
:{} { 
  ( "modifies"
    ( Idents()        
    )? ";"
  | "free" SpecPrePost()
  | SpecPrePost()
  )
}

void SpecPrePost()
:{} { 
  ( "requires"              
    ( Attribute() )*
    Expression() ";"  
  | "ensures"               
    ( Attribute() )*
    Expression() ";"  
  )
}

/*------------------------------------------------------------------------*/

void ImplBody()
:{} { 
  "{"
  ( LocalVars() )*
  StmtList()
}

/* the StmtList also reads the final curly brace */
void StmtList()
:{} { 

  (
    LabelOrCmd()
  | StructuredCmd()
  | TransferCmd()
  )*
  
  "}"
}

void TransferCmd()
:{} { 
  ( "goto"             
    Idents()     
  | "return"           
  ) ";"
}

void StructuredCmd()
:{} { 
  ( IfCmd()    
  | WhileCmd()  
  | BreakCmd()  
  )
}

void IfCmd()
:{} { 
  "if"                       
  Guard()
  "{" StmtList()
  ( "else"
    ( IfCmd()      
    | "{"
      StmtList()      
    )
  )?
  
}

void WhileCmd()
:{} { 
  "while"             
  Guard()    
  (                   
    ( "free"          
    )?
    "invariant"
    Expression() 
    ";"
  )*
  "{"
  StmtList()  
}

void Guard()
:{} { 
  "("
  ( "*"                   
  | Expression()    
  )
  ")"
}

void BreakCmd()
:{} { 
  "break"             
  ( <IDENT>      
  )? ";"               
}

/*------------------------------------------------------------------------*/

void LabelOrCmd()
/* ensures (c == null) != (label != null) */
:{} { 
  ( LabelOrAssign()
  | "assert"              
    ( Attribute() )*
    Expression()    
    ";"
  | "assume"              
    Expression()    
    ";"
  | "havoc"               
    Idents() ";"    
  | CallCmd() ";"   
  )
}

/*------------------------------------------------------------------------*/

void LabelOrAssign()
/* ensures (c == null) != (label != null) */
:{} { 
  <IDENT>          
  ( ":"                      

  | 
    

    ( MapAssignIndex()     )*
    

    ( ","
      <IDENT>
      
      ( MapAssignIndex()     )*
      
    )*

    ":="                     
    Expression()       
    ( ","
      Expression()     
    )*
    ";"                      
  )
}

void MapAssignIndex()
:{} { 
  "["                        
    (
      Expression()      
      ( ","
        Expression()    
      )*
    )?
  "]"
}

/*------------------------------------------------------------------------*/
void CallCmd()
:{} { 
  "call"                          
  ( Attribute() )*
  ( <IDENT>
    ( "("
      ( CallForallArg()       
        ( "," CallForallArg() 
        )*
      )?
      ")"                         
    |
                                  
      ( "," CallOutIdent()  
        ( "," CallOutIdent()  
        )*
      )? ":="
      <IDENT> "("
      ( CallForallArg()       
        ( "," CallForallArg() 
        )*
      )?
      ")"                         
    )
  | <OP_FORALL>
    <IDENT> "("              
    ( CallForallArg()       
      ( "," CallForallArg() 
      )*
    )?
    ")"                           
  | "*"
                                  
      ( "," CallOutIdent()  
        ( "," CallOutIdent()  
        )*
      )? ":="
      <IDENT> "("
      ( CallForallArg()       
        ( "," CallForallArg() 
        )*
      )?
      ")"                         
  )
}

void CallOutIdent()
:{} { 
  ( "*"
  | <IDENT>                   
  )
}

void CallForallArg()
:{} { 
  ( "*"
  | Expression()             
  )
}

/*------------------------------------------------------------------------*/
List<Token> Idents()
:{
    Token n;
    List<Token> rval = new LinkedList<Token>();
} { 
  n=<IDENT> { rval.add(n); }           
  ( "," n=<IDENT> { rval.add(n); }
  )*
  {return rval;}
}

/*------------------------------------------------------------------------*/
List<String> WhiteSpaceIdents()
:{
    Token t;
    List<String> rval = new LinkedList<String>();
} {                
  (t=<IDENT> {rval.add(t.image);}               
  )+
  {return rval;}
}

/*------------------------------------------------------------------------*/
Expression Expressions()
:{
 // TODO continue here!
} { 
  Expression()             
  ( "," Expression()       
  )*
  {return new Expression();}
}

/*------------------------------------------------------------------------*/
Expression Expression()
:{} { 
  ImpliesExpression()
  ( EquivOp()        
    ImpliesExpression()                   
  )*
  { return new Expression(); }
}

void EquivOp(): {}
{
  ("<==>" | "\u21d4")
}

/*------------------------------------------------------------------------*/
void ImpliesExpression()
:{} { 
  LogicalExpression()
  (
    ImpliesOp()      
    /* recurse because implication is right-associative */
    ImpliesExpression()
                   
  |
    ExpliesOp()      
    LogicalExpression() 
                   
    /* loop because explies is left-associative */
    (
      ExpliesOp()    
      LogicalExpression() 
                   
    )*
  )?
}

void ImpliesOp() 
:{}{
 ( "==>" | "\u21d2" )
}

void ExpliesOp()
:{}{
 ( "<==" | "\u21d0" )
}

/*------------------------------------------------------------------------*/
void LogicalExpression()
:{} { 
  RelationalExpression()
  ( AndOp()          
    RelationalExpression()
    
    ( AndOp()        
      RelationalExpression()
      
    )*
  | OrOp()           
    RelationalExpression()
    
    ( OrOp()         
      RelationalExpression()
      
    )*
  )?
}

void AndOp()
:{}{
 ( "&&" | "\u2227" )
}

void OrOp()
:{}{
 ( "||" | "\u2228" )
}

/*------------------------------------------------------------------------*/
void RelationalExpression()
:{} { 
  BvTerm()
  ( RelOp()
    BvTerm()            
  )?
}

void RelOp()
:{} {                  
  ( "=="           
  | "<"            
  | ">"            
  | "<="           
  | ">="           
  | "!="           
  | "<:"           
  | "\u2260"       
  | "\u2264"       
  | "\u2265"       
  )
}

/*------------------------------------------------------------------------*/
void BvTerm()
:{} { 
  Term()
  ( "++"                  
    Term()          
  )*
}


/*------------------------------------------------------------------------*/
void Term()
:{} { 
  Factor()
  ( AddOp()
    Factor()          
  )*
}

void AddOp()
:{} {                  
  ( "+"            
  | "-"            
  )
}

/*------------------------------------------------------------------------*/
void Factor()
:{} { 
  UnaryExpression()
  ( MulOp()
    UnaryExpression() 
  )*
}

void MulOp()
:{} {                  
  ( "*"            
  | "/"            
  | "%"            
  )
}

/*------------------------------------------------------------------------*/
void UnaryExpression()
:{} { 
  ( "-"                        
    UnaryExpression()     
  | NegOp()                      
    UnaryExpression()     
  | CoercionExpression()
  )
}

void NegOp()
:{} {
 ( "!" | "\u00ac" )
}

/*------------------------------------------------------------------------*/

/* This production creates ambiguities, because types can start with "<"
   (polymorphic map types), but can also be followed by "<" (inequalities).
   Coco deals with these ambiguities in a reasonable way by preferring to read
   further types (type arguments) over relational symbols. E.g., "5 : C < 0"
   will cause a parse error because "<" is treated as the beginning of a
   map type. */
   
void CoercionExpression() :{} { 
  ArrayExpression()
  ( ":"                     
    (
      Type()   
    | <INTEGER>           /* This means that we really look at a bitvector expression t(a:b)? */
    )
  )*
}

/*------------------------------------------------------------------------*/
void ArrayExpression()
:{} { 
  AtomExpression()
  ( "["        
      (
        Expression() 
               
        ( "," Expression() 
               
        )*
        ( ":=" Expression() 
               
        )?
      | ":=" Expression()       
      )?
    "]"
  )*
}


/*------------------------------------------------------------------------*/
void AtomExpression()
:{} { 
  ( "false"           
  | "true"            
  | <INTEGER>          
  | <BVLIT> 
  | <IDENT>            
    ( "("
      ( Expressions() )? // MU: was empty choice
      ")"
    )?

  | "old"                   
    "("
    Expression()
    ")"                     

  | "(" ( Expression()                 
        | <OP_FORALL>                            
          QuantifierBody()
                                            
        | <OP_EXISTS>                            
          QuantifierBody() 
                                            
        | <OP_LAMBDA>                         
          QuantifierBody() 
                                            
        )
    ")"
  | IfThenElseExpression()
  | CodeExpression() 
  )
}

void CodeExpression()
:{} { 
  "|{"
  ( LocalVars() )*
  SpecBlock()          
  ( SpecBlock()        
  )*
  "}|"
}

void SpecBlock()
:{} { 
  <IDENT> ":"
  ( LabelOrCmd()
                       
  )*
  ( "goto"             
    Idents()     
  | "return" Expression()
                       
  )
  ";"
}

List<Attribute> AttributeList()
:{
    Attribute attr;
    List<Attribute> rval = new LinkedList<Attribute>();
} {
    ( attr=Attribute() {rval.add(attr);} )*
    {return rval;}
}

// TODO implement
Attribute Attribute()
:{} { 
  AttributeOrTrigger()
  { return new Attribute(); } 
}

void AttributeOrTrigger()
:{} { 
  "{"                                         
     (
       ":" <IDENT>                              
       ( AttributeParameter()        
         ( "," AttributeParameter()  
         )*
       )?
       
     |
       Expression()       
       ( "," Expression() 
       )*                       
     )
  "}"
}

void AttributeParameter()
:{} { 
  ( <STRING>                
  | Expression()     
  )
}

void IfThenElseExpression()
:{} { 
  "if"  Expression() "then" Expression() "else" Expression()
  
}


void QuantifierBody()
:{} { 
  (
     TypeParams()
     ( BoundVars() )?
  |
     BoundVars()
  )
  <OP_SEP>
  ( AttributeOrTrigger() )*
  Expression()
}
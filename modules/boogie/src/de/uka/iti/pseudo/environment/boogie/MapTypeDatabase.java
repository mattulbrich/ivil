package de.uka.iti.pseudo.environment.boogie;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import de.uka.iti.pseudo.environment.Environment;
import de.uka.iti.pseudo.environment.EnvironmentException;
import de.uka.iti.pseudo.environment.Sort;
import de.uka.iti.pseudo.parser.ASTLocatedElement;
import de.uka.iti.pseudo.term.TermException;
import de.uka.iti.pseudo.term.Type;
import de.uka.iti.pseudo.term.TypeApplication;
import de.uka.iti.pseudo.term.TypeVariable;

/**
 * This class maps map types to ivil types. Map types are normalised to ensure
 * correct treatment of type equivalence.
 * 
 * @author timm.felden@felden.com
 * 
 *         TODO document silently assumed invariants, which make this
 *         translation work
 */
public final class MapTypeDatabase {

    /**
     * this direction is needed to add new map types
     */
    final Map<BoogieMap, Type> mapTo = new HashMap<BoogieMap, Type>();
    final Map<Sort, BoogieMap> mapFrom = new HashMap<Sort, BoogieMap>();

    private final Environment env;

    public MapTypeDatabase(Environment env) {
        this.env = env;
    }

    /**
     * @note Map DB has to be type parameter name agnostic, as this would break
     *       typing. If type parameter renaming is required, a mechanism is
     *       needed that renames type parameters, before(or during) the type map
     *       is built, by structure.
     * 
     * @param node
     *            the node that caused the creation of this type
     * @param state
     *            the state is used to create new rules, etc., for maybe created
     *            map types
     * 
     * 
     * @return a type with no arguments built from a sort map<%i>
     * @throws TypeSystemException
     *             If the defined type is ill-formed
     */
    public Type getType(Type[] domain, Type range, TypeVariable[] parameters, ASTLocatedElement node,
            EnvironmentCreationState state) throws TypeSystemException {

        // create an unfolded map
        BoogieMap entry = new BoogieMap(Arrays.asList(parameters), Arrays.asList(domain), range,
                node);

        // add a new map to the table
        return addMapType(entry, node);
    }

    /**
     * requires definition to be a map type
     * 
     * @return a copy of the domain array
     */
    public Type[] getDomain(Type definition) {
        assert hasType(definition) : "requires definition to be a map type";

        final List<Type> d = mapFrom.get(((TypeApplication) definition).getSort()).getDomain();

        return d.toArray(new Type[d.size()]);
    }

    /**
     * requires definition to be a map type
     * 
     * @return the range of definition
     */
    public Type getRange(Type definition) {
        assert hasType(definition) : "requires definition to be a map type";

        return mapFrom.get(((TypeApplication) definition).getSort()).getRange();
    }

    /**
     * requires definition to be a map type
     * 
     * @return the parameters of definition
     */
    public TypeVariable[] getParameters(Type definition) {
        assert hasType(definition) : "requires definition to be a map type";

        List<TypeVariable> p = mapFrom.get(((TypeApplication) definition).getSort()).getBoundVars();

        return p.toArray(new TypeVariable[p.size()]);
    }

    // used by inference path
    BoogieMap getBoogieMap(Type definition) {
        assert hasType(definition) : "requires definition to be a map type (was : " + definition + ")";

        return mapFrom.get(((TypeApplication) definition).getSort());
    }

    /**
     * Checks if the supplied type was generated by this database.
     * 
     * @param type
     * 
     * @return true iff the type refers to a type, that is known and created by
     *         this object
     */
    public boolean hasType(Type type) {
        if (type instanceof TypeApplication)
            return mapFrom.containsKey(((TypeApplication) type).getSort());
        return false;
    }

    /**
     * Creates sort, functions and rules for type and returns the ivil type.
     * 
     * @param type
     * @return the ivil type that can be used to represent the map
     * 
     * @throws TypeSystemException
     *             if type creation failed
     * 
     */
    private Type addMapType(BoogieMap type, ASTLocatedElement astLocatedElement) throws TypeSystemException {
        try {
            return type.flatten(env, null, this);
        } catch (EnvironmentException e) {
            e.printStackTrace();
            throw new TypeSystemException("type flattening failed", e);
        } catch (TermException e) {
            e.printStackTrace();
            throw new TypeSystemException("type flattening failed", e);
        }
    }

    @Override
    public String toString() {
        StringBuffer b = new StringBuffer();
        for (Sort s : mapFrom.keySet()) {
            b.append(s);
            b.append(" ==> ");
            b.append(mapFrom.get(s));
            b.append('\n');
        }
        return b.toString();
    }

}

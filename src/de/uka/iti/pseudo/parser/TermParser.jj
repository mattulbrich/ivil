
options {
        STATIC = false;
}

PARSER_BEGIN(TermParser)
package de.uka.iti.pseudo.parser.term;

import java.util.*;
import java.io.*;

public class TermParser {

    private String fileName;

    public TermParser(String string, String fileName, int line, int col) {
        this(new StringReader(string));
        this.fileName = fileName;
        jj_input_stream.line = line;
        jj_input_stream.column = col;
    }
    
    public ASTTerm parseTerm() throws ParseException 
    {
    	ASTTerm term = Term();
    	term.setFilename(fileName);
    	return term;
    }
  
}

PARSER_END(TermParser)

//
// (* COMMENTS *)
TOKEN_MGR_DECLS : {
    int commentNestingDepth ; 
}
    
// When a "(*" is encounted in the DEFAULT state, set the counter to 1 and enter the COMMENT state:
SKIP : {  "(*" { commentNestingDepth = 1 ; } : COMMENT }

// When a "(*" is encounted in the COMMENT state, increment the counter:
< COMMENT >  SKIP : {  "(*" { commentNestingDepth += 1 ; } }

// When a "*)" is encountered in the COMMENT state, either switch back to the DEFAULT state or stay in the comment state:
< COMMENT >  SKIP : {  "*)" { commentNestingDepth -= 1; SwitchTo( 
                              commentNestingDepth==0 ? DEFAULT : COMMENT ) ; } } 

// Finally a rule is needed to mop up all the other characters in the comment.
< COMMENT >  SKIP : {  < ~[] > }

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{

// Logics
  < LEFTPAREN: "(" >
| < RIGHTPAREN: ")" >
| < LEFTSQUARE: "[" >
| < RIGHTSQUARE: "]" >
| < COMMA: "," >
| < SEMICOLON: ";" >
| < AS: "as" >

// Programs
| < _SKIP: "skip" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < INV: "inv" >
| < DO: "do" >
| < END: "end" >
| < ASSIGN: ":=" >

// Identifiers
| < BINDER_IDENTIFIER: "\\" <IDENTIFIER> >
| < TYVAR_IDENTIFIER: "'" <IDENTIFIER> >
| < SCHEMA_IDENTIFIER: "%" <IDENTIFIER> >
| < SCHEMAMOD_IDENTIFIER: "&" <IDENTIFIER> >
| < INTERNAL_IDENTIFIER : "$" <IDENTIFIER> >
| < META_IDENTIFIER: "$$" <IDENTIFIER> >
| < IDENTIFIER: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","0"-"9","_","'"] )* >
| < OP_IDENTIFIER: ( ["+","-","<",">","&","|","=","*","/","!","^"] )+ >

// Literals
| < NUMBERLITERAL: ( ["0" - "9"] )+ >

}

ASTTerm Term():
{ 
  ASTTerm term;
  List<ASTTerm> list = new ArrayList<ASTTerm>(); 
}
{

        ( term=OpIdentifier() { list.add(term); } )*
        term=ModalityTerm() { list.add(term); }
        (
          ( term=OpIdentifier() { list.add(term); } )+
          term=ModalityTerm() { list.add(term); }
        )*
   { 
     if(list.size() > 1)
        return new ASTListTerm(list);
     else
        return list.get(0);
   }
}

ASTTerm ModalityTerm():
{
  ASTModality modality = null;
  ASTTerm term;
}
{
      "[" modality=ModalityList() "]" term=ModalityTerm()
         { return new ASTModalityTerm(modality, term); }
    | 
      term=AsTerm()
         { return term; } 
}

ASTTerm AsTerm():
{ 
  ASTTerm term;
  ASTType type; 
}
{
        term=BaseTerm()
        (
          "as"
          type=TypeRef()
            { term = new ASTAsType(term, type); }
        )?  
         { return term; }
}

ASTTerm BaseTerm():
{ 
  ASTTerm term;
}
{
        ( LOOKAHEAD(2) "(" term=BinderTerm() ")"
        | "(" term=Term() ")"
        | term=ApplicationTerm()
        | term=SchemaVariable()
        | term=NumberLiteral()
        )
        { return term; }
}

ASTBinderTerm BinderTerm():
{
  Token binderToken;
  Token varToken;
  ASTType type = null; 
  ASTTerm t;
  List<ASTTerm> subterms = new ArrayList<ASTTerm>(); 
}
{
        binderToken = <BINDER_IDENTIFIER>
        
        ( varToken=<IDENTIFIER> | varToken=<SCHEMA_IDENTIFIER> )
        ( "as" type = TypeRef() )?
        ( ";" t=Term() { subterms.add(t); } )+
   { return new ASTBinderTerm(binderToken, type, varToken, subterms); }
}

ASTType TypeRef():
{
  Token token;
  List<ASTType> args = new ArrayList<ASTType>();
  ASTType ty;
}
{
		token = <IDENTIFIER>
		(
		  "(" ty=TypeRef() { args.add(ty); }
		  		( "," ty=TypeRef() { args.add(ty); } )*
		  ")"
		)?
		{ return new ASTTypeApplication(token, args); }
	|
		token = <TYVAR_IDENTIFIER>
		{ return new ASTTypeVar(token); }
}

        
ASTTerm ApplicationTerm():
{
  Token symbol;
  ASTTerm t;
  List<ASTTerm> subterms = new ArrayList<ASTTerm>();
}
{
        (symbol=<IDENTIFIER> | symbol=<META_IDENTIFIER> | symbol=<INTERNAL_IDENTIFIER>)
        
        ( /* parentheses are not empty, constants dont have them */ 
          "("
          t=Term() { subterms.add(t); }
          ( "," t=Term() { subterms.add(t); } )*
          ")"
        )?
        
    { if(subterms.size() > 0) 
        return new ASTApplicationTerm(symbol, subterms); 
      else
        return new ASTIdentifierTerm(symbol);
    }
}

ASTTerm OpIdentifier():
{ 
  Token t;
}
{
        t=<OP_IDENTIFIER> 
  { return new ASTOperatorIdentifierTerm(t); }
}

ASTNumberLiteralTerm NumberLiteral():
{
  Token t;
}
{
        t=<NUMBERLITERAL>
  { return new ASTNumberLiteralTerm(t); }
}

ASTSchemaVariableTerm SchemaVariable():
{
	Token t;
}
{
        t=<SCHEMA_IDENTIFIER>
  { return new ASTSchemaVariableTerm(t); }
}

ASTModality ModalityList():
{
  ASTModality mod;
  List<ASTModality> list = new ArrayList<ASTModality>();
}
{
  mod=Modality()
    { list.add(mod); }
  (
    ";"
    mod=Modality()
      { list.add(mod); }
  )*
  
  { return list.size() == 1 ? 
  	   mod : new ASTModCompound(list); }
}

ASTModality Modality():
{
  ASTTerm term, term2 = null, term3;
  ASTModality mod, mod2 = null;
  Token id;
  Token t;
}
{
        ( id=<IDENTIFIER> | id=<SCHEMA_IDENTIFIER> ) ":=" term=Term()
            { return new ASTModAssignment(id, term); }
        | t="while" term=Term() ( "inv" term2=Term() )? "do" mod=ModalityList() "end"
            { return new ASTModWhile(t, term, term2, mod); }
        | t="if" term=Term() "then" mod=ModalityList() 
            ( "else" mod2=ModalityList() )? "end"
            { return new ASTModIf(t, term, mod, mod2); }
        | t="skip"
            { return new ASTModSkip(t); }
        | id=<SCHEMAMOD_IDENTIFIER>
            { return new ASTModSchema(id); }
}
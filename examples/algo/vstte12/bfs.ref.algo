uses "bfs.decl.p"
uses "ref-BFS.minDistance(int,int).p"

/* this can becomen general theory! */
uses inline
function
   int vi('a)
   'a iv(int)

axiom vi_is_positive
   (\T_all 'a; (\forall x as 'a; vi(x) ~~> vi(x) >= 0))

axiom vi_finite_bounded
   (\T_all 'a; (\forall x as 'a; vi(x) ~~> 
       finite(fullset as set('a)) -> vi(x) < card(fullset as set('a))))

axiom vi_injection
   (\T_all 'a; (\forall x as 'a; vi(x) ~~>
       finite(fullset as set('a)) -> iv(vi(x)) = x ))

axiom iv_injection
   (\T_all 'a; (\forall i; iv(i) as 'a~~>
          finite(fullset as set('a)) & 0<=i & i<card(fullset as set('a))
       -> vi(iv(i) as 'a) = i))

end


abbreviation
   @vars_coupled :=
       V = (\set v; h[_V, idxBool(vi(v))])
     & C = (\set v; h[_C, idxBool(vi(v))])
     & N = (\set v; h[_N, idxBool(vi(v))])
     & d = _d
     & vi(src) = _src
     & vi(dest) = _dest
     
abbreviation
   @arrays :=
       !(_V=_N) & !(_N=_C) & !(_V=_C) &
       arrlen(_V) = size &
       arrlen(_N) = size &
       arrlen(_C) = size &
       size = card(fullset as set(vertex))

abbreviation
   @succ :=
       (\forall v; succ(v) = 
               (\set w; (\exists i; 0 <= i & i < size & 
                        h[h[h[_this, F_BFS_adjacency], idxRef(vi(v))], idxBool(vi(w))])))

algo bfs
input
   src, dest : vertex
output
   d : int
var
   size : int
   V, C, N : set(vertex)
   Vo, Co, No : set(vertex)
   tovisit : set(vertex)
   v,w : vertex
   
requires 
   finite(fullset as set(vertex))

ensures
   d >= -1
   
ensures
   d < 0 -> (\forall m; m >= 0 -> not minconnect(src,dest,m))
   
ensures
   d >= 0 -> minconnect(src, dest, d) 

do
   size := card(fullset as set(vertex));
   
   V := {src};
   C := {src};
   N := {};
   d := 0;

   while !(C = {})
     inv d >= 0 &
       (\forall x; x in C -> minconnect(src, x, d)) &
       (\forall y; y in N <-> 
           (\exists q; minconnect(src, q, d) & not q in C & y in succ(q))) &
       (\forall z; z in V \ N <->
           (\exists n; 0 <= n <= d & minconnect(src, z, n))) &
       (\forall a; minconnect(src, a, d+1) ->
           (\exists c; a in succ(c) & c in C) | a in N) &
       (C = {} -> N = {}) &
       C <: V &
       N <: V &
       not dest in (V \ N) \ C
     var ^(V \ (C \/ N))
   do
     mark 1;

     choose v such that v in C
       hint "§(rule deep_update_simplification) §(inst x1 with 'iv(_v) as vertex' hide)";

     C := C \ {v};
     if v = dest 
     then 
       return
     end;
     
     Vo := V;
     No := N;

     iterate succ(v) with w in tovisit
       inv tovisit <: succ(v) &
           V = Vo \/ (succ(v) \ tovisit) &
           N = No \/ (succ(v) \ (Vo \/ tovisit))
       hint "§(rule deep_update_simplification) §(inst x1 with 'iv(_w) as vertex' hide)"
     do 
       mark 2;
       if not w in V
       then
         V := V \/ {w};
         N := N \/ {w}
       end
     end;
     
     if C = {}
     then
       C := N;
       N := {};
       d := d+1
     end
         
   end;

   note (\forall i; i>=0 -> (\forall a; !minconnect(src, a, d+1+i)))
     hint "§(rule int_induction_match)";

   note (\forall j; j>d -> !minconnect(src, dest, j))
     hint "§(rule deep_update_simplification nested_quant_z3)";

   d := -1
end 

refine bfs as Java 

  requires @succ & vi(src) = _src & vi(dest) = _dest
        &  finite(fullset as set(vertex)) 
        &  card(fullset as set(vertex)) = h[_this, F_BFS_size]
    var pair(1, pair(V, V))

  ensures d = resInt

  mark 1
    inv @vars_coupled & @arrays & !C={}
    var pair(0, pair(V^(V \ (C \/ N)), tovisit))

  mark 2
    inv @vars_coupled & @arrays & _v = vi(v) & _w = vi(w) & tovisit = (\set v; vi(v) > _w) /\ succs(v)
    var pair(0, pair(V^(V \ (C \/ N)), tovisit))


options {
        STATIC = false;
}

PARSER_BEGIN(TermParser)
package de.uka.iti.pseudo.parser.term;

import java.util.*;
import java.io.*;
import de.uka.iti.pseudo.environment.InfixOperator;
import de.uka.iti.pseudo.util.Pair;

public class TermParser {

    private HashMap<String, InfixOperator> infixTable = new HashMap<String, InfixOperator>();
  
    TermParser() {
        this(new StringReader(""));
    }
  
    ASTTerm shuntingYard(int prec) throws ParseException {
        Stack<Pair<Token, InfixOperator>> opStack =
            new Stack<Pair<Token, InfixOperator>>();
        Stack<ASTTerm> termStack =
            new Stack<ASTTerm>();

        loop: while (true) {

            Token token = getToken(1);

            InfixOperator infixOp = null;

            switch (token.kind) {
            case IDENTIFIER:
                infixOp = infixTable.get(token.image);
                if (infixOp == null) {
                    termStack.push(ApplicationTerm());
                    continue loop;
                }
                break;

            case OPIDENTIFIER:
                infixOp = infixTable.get(token.image);
                if (infixOp == null) {
                    throw new ParseException("think up something");
                }
                break;

            case NUMBERLITERAL:
                termStack.push(NumberLiteral());
                break;

            default:
                break loop;
            }

            assert infixOp != null;

            if (opStack.empty()
                    || opStack.peek().snd().getPrecedence() > infixOp
                            .getPrecedence()) {
                opStack.push(new Pair<Token, InfixOperator>(token, infixOp));
            } else {
                if (termStack.size() < 2) {
                    throw new ParseException();
                }
                ASTTerm t2 = termStack.pop();
                ASTTerm t1 = termStack.pop();
                ASTTerm result = new ASTInfixTerm(token, infixOp, t1, t2);
                termStack.push(result);
            }

            getNextToken();

        }

        while (termStack.size() >= 2) {
            assert !opStack.empty();
            Pair<Token, InfixOperator> tokenAndOp = opStack.pop();
            ASTTerm t2 = termStack.pop();
            ASTTerm t1 = termStack.pop();
            ASTTerm result = new ASTInfixTerm(tokenAndOp, t1, t2);
            termStack.push(result);
        }

        if (termStack.size() != 1 || !opStack.empty()) {
            throw new ParseException();
        }

        return termStack.pop();
    }
}

PARSER_END(TermParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{

// Logics
  < LEFTPAREN: "(" >
| < RIGHTPAREN: ")" >
| < LEFTSQUARE: "[" >
| < RIGHTSQUARE: "]" >
| < COMMA: "," >
| < SEMICOLON: ";" >
| < DOT: "." >
| < OR: "|" >
| < NOT: "~" >
| < IMPLIES: "->" >
| < EQUIV: "<->" >
| < EQUALS: "=" >  
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >

// Programs
| < WHILE: "while" >
| < DO: "do" >
| < END: "end" >
| < ASSIGN: ":=" >

// Identifiers
| < BINDERIDENTIFIER: "\\" <IDENTIFIER> >
| < TYVARIDENTIFIER: "'" <IDENTIFIER> >
| < IDENTIFIER: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","0"-"9","_","'"] )* >
| < OPIDENTIFIER: ( ["+","-","<",">","&","|","=","*","/"] )+ >

// Literals
| < NUMBERLITERAL: ( ["0" - "9"] )+ >
| < OTHER: ["\u0000"-"\uFFFF"] >

}

ASTTerm Term():
{ ASTTerm term; }
{
        (
          LOOKAHEAD( GeneralIdentifier() ) term=PrecedenceTerm()
        | term=AtomicTerm() 
        )
   { return term; }
}

ASTTerm AtomicTerm():
{ ASTTerm term; }
{
        ( LOOKAHEAD(2) "(" term=BinderTerm() ")"
        | LOOKAHEAD(2) "(" term=Term() ")"
        | term=ApplicationTerm()
        | term=ModalityTerm()
        | "(" term=IfThenElseTerm() ")"
        ) { return term; }
}

ASTBinderTerm BinderTerm():
{
  Token binderToken;
  Token varToken;
  ASTTypeRef type; 
  ASTTerm t;
  List<ASTTerm> subterms = new ArrayList<ASTTerm>(); 
}
{
        binderToken = <BINDERIDENTIFIER>
        type = TypeRef()
        varToken = <IDENTIFIER>
        ( ";" t=Term() { subterms.add(t); } )+
   { return new ASTBinderTerm(binderToken, type, varToken, subterms); }
}

ASTTypeRef TypeRef():
{
  Token token;
  List<ASTTypeRef> args = new ArrayList<ASTTypeRef>();
  ASTTypeRef ty;
}
{
		token = <IDENTIFIER>
		(
		  "(" ty=TypeRef() { args.add(ty); }
		  		( "," ty=TypeRef() { args.add(ty); } )*
		  ")"
		)?
		{ return new ASTTypeRef(token, args); }
}


ASTIfThenElseTerm IfThenElseTerm():
{
  ASTTerm condTerm, thenTerm, elseTerm; 
}
{
        "if"
        condTerm=Term()
        "then"
        thenTerm=Term()
        "else"
        elseTerm=Term()
   { return new ASTIfThenElseTerm(condTerm, thenTerm, elseTerm); }
}  
        
ASTApplicationTerm ApplicationTerm():
{
  Token symbol;
  ASTTerm t;
  List<ASTTerm> subterms = new ArrayList<ASTTerm>();
}
{
        symbol = <IDENTIFIER>
        
        ( /* parentheses are not empty, constants dont have them */ 
          "("
          t = Term() { subterms.add(t); }
          ( "," t = Term() { subterms.add(t); } )*
          ")"
        )?
        
    { return new ASTApplicationTerm(symbol, subterms); }
}

Token GeneralIdentifier():
{ 
  Token t;
}
{
        (t=<IDENTIFIER> | t=<OPIDENTIFIER>) 
  { return t; }
}

ASTNumberLiteralTerm NumberLiteral():
{
  Token t;
}
{
        t=<NUMBERLITERAL>
  { return new ASTNumberLiteralTerm(t); }
}

ASTModalityTerm ModalityTerm():
{
  ASTModality modality;
  ASTTerm term;
}
{
        "[" modality=Modality() "]"
        term=Term()
  { return new ASTModalityTerm(modality, term); }
}

ASTModality Modality():
{
  ASTTerm term, term2, term3;
  ASTModality mod;
  Token id;
}
{
          id=<IDENTIFIER> ":=" term=Term()
            { return new ASTModAssignment(id, term); }
        | "while" term=Term() "do" mod=Modality() "end"
            { return new ASTModWhile(term, mod); }
        | "if" term=Term() "then" term2=Term() "else" term3=Term()
            { return new ASTModIf(term, term2, term3); }
}

JAVACODE ASTTerm PrecedenceTerm() {
    return shuntingYard(0);
}





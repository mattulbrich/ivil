(* created : Fri Aug 24 11:53:44 CEST 2012 - Alpha-3 *)
#
# This file was generated by PSEUDO
# which is copyright (C) 2009 Universitaet Karlsruhe, Germany
#    written by Mattias Ulbrich
#

include "$bytecode.p"

include "declarations.p"

(* program variables *)
function
   ref _a assignable (* local variable '1' *)
   ref pre_a assignable (* method parameter, prestate *)
   int _x assignable (* local variable '2' *)
   int pre_x assignable (* method parameter, prestate *)
   int _y assignable (* local variable '3' *)
   int pre_y assignable (* method parameter, prestate *)
   bool st_0_bool assignable (* stack variable *)
   int st_0_int assignable (* stack variable *)
   int _i assignable (* local variable '4' *)
   heap ho1 assignable (* Heap snapshot for loop invariant *)
   int st_1_int assignable (* stack variable *)
   ref st_1_ref assignable (* stack variable *)
   bool branchCond assignable (* branching condition *)
   ref st_0_ref assignable (* stack variable *)
   int st_2_int assignable (* stack variable *)
   int st_3_int assignable (* stack variable *)

(* the translated Java program *)
program Java source "./A.jspec"
   sourceline 5
    assume 0 <= _x & _x < arrlen(_a) ; "Assume precondition"
   sourceline 6
    assume 0 <= _y & _y < arrlen(_a) ; "Assume precondition"
   sourceline 7
    assume ! _a = null ; "Assume precondition"
    assume wellformed(h) ; "assumption guaranteed by Java"
    assume !_this = null ; "assumption guaranteed by Java"
    assume h[_this, created] ; "assumption guaranteed by Java"
    pre_h := h || pre_a := _a || pre_x := _x || pre_y := _y ; "Recording the prestate"
  Label1:
   sourceline 19
    (* ICONST_0 *)
    st_0_bool := false
    st_0_int := 0
    (* ISTORE *)
    _i := st_0_int
  Label2:
   sourceline 21
    (* LDC + INVOKESTATIC - Specification injection *)
    ho1 := h
    (* spec statement deferred till after looping point *)
  Label3:
    (* deferred specification statement *)
    skip LOOPINV, {ho := ho1}((0<=_i & _i<=arrlen(_a)-_x & _i<=arrlen(_a)-_y &
	    (\forall j; 0<=j & j < _i -> 
	       h[_a, idxInt(_x + j)] = h[_a, idxInt(_y + j)])) & modHeap(h, ho, emptyset)), arrlen(_a) - _i
   sourceline 30
    (* ILOAD *)
    st_0_int := _x
    (* ILOAD *)
    st_1_int := _i
    (* IADD *)
    st_0_int := st_0_int + st_1_int
    (* ALOAD *)
    st_1_ref := _a
    (* ARRAYLENGTH *)
    assert !st_1_ref = null ; "non-null array reference"
    st_1_int := arrlen(st_1_ref)
    (* IF_ICMPGE *)
    branchCond := st_0_int >= st_1_int
    goto Label4, Label5
  Label4:
    assume branchCond
    goto Label6
  Label5:
    assume !branchCond
    (* ILOAD *)
    st_0_int := _y
    (* ILOAD *)
    st_1_int := _i
    (* IADD *)
    st_0_int := st_0_int + st_1_int
    (* ALOAD *)
    st_1_ref := _a
    (* ARRAYLENGTH *)
    assert !st_1_ref = null ; "non-null array reference"
    st_1_int := arrlen(st_1_ref)
    (* IF_ICMPGE *)
    branchCond := st_0_int >= st_1_int
    goto Label7, Label8
  Label7:
    assume branchCond
    goto Label6
  Label8:
    assume !branchCond
    (* ALOAD *)
    st_0_ref := _a
    (* ILOAD *)
    st_1_int := _x
    (* ILOAD *)
    st_2_int := _i
    (* IADD *)
    st_1_int := st_1_int + st_2_int
    (* IALOAD *)
    assert !st_0_ref = null ; "non-null array access"
    assert st_1_int >= 0 & st_1_int < arrlen(st_0_ref) ; "array index in bounds"
    st_0_int := h[st_0_ref, idxInt(st_1_int)] ; "read value from array"
    (* ALOAD *)
    st_1_ref := _a
    (* ILOAD *)
    st_2_int := _y
    (* ILOAD *)
    st_3_int := _i
    (* IADD *)
    st_2_int := st_2_int + st_3_int
    (* IALOAD *)
    assert !st_1_ref = null ; "non-null array access"
    assert st_2_int >= 0 & st_2_int < arrlen(st_1_ref) ; "array index in bounds"
    st_1_int := h[st_1_ref, idxInt(st_2_int)] ; "read value from array"
    (* IF_ICMPNE *)
    branchCond := !st_0_int = st_1_int
    goto Label9, Label10
  Label9:
    assume branchCond
    goto Label6
  Label10:
    assume !branchCond
  Label11:
   sourceline 32
    (* IINC *)
    _i := _i + 1
    (* GOTO *)
    goto Label3
  Label6:
   sourceline 35
    (* ILOAD *)
    st_0_int := _i
    (* IRETURN *)
    exc := null
    resInt := st_0_int
    goto LabelEnd
  Label12:
  LabelEnd:
    assert exc = null ; "No exception has been thrown"
   sourceline 8
    assert 0 <= resInt ; "Assert postcondition"
   sourceline 9
    assert resInt <= arrlen(_a) - _x ; "Assert postcondition"
   sourceline 10
    assert resInt <= arrlen(_a) - _y ; "Assert postcondition"
   sourceline 11
    assert (\forall i; 0 <= i & i < resInt ->
                       h[_a, idxInt(_x + i)] = h[_a, idxInt(_y + i)]) ; "Assert postcondition"
   sourceline 13
    assert resInt = arrlen(_a) - _x |
                 resInt = arrlen(_a) - _y |
                 !h[_a, idxInt(_x + resInt)] = h[_a, idxInt(_y + resInt)] ; "Assert postcondition"
   sourceline 16
    assert modHeap(h, pre_h, {h:=pre_h}(emptyset))
(* end of program *)



options {
   STATIC=false;
}

PARSER_BEGIN(FileParser)
package de.uka.iti.pseudo.parser.file;

import java.util.*;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.Reader;
import java.io.StringReader;

import de.uka.iti.pseudo.util.Pair;

public class FileParser {

    public FileParser() {
       this(new StringReader(""));
    }

    public ASTFile parseFile(File file) throws FileNotFoundException, ParseException {
       return parseFile(new FileReader(file), file.getPath());
    }
    
    public ASTFile parseFile(Reader reader, String filename) throws ParseException {
        ReInit(reader);
        ASTFile result = File();
        result.setFilename(filename);
        return result;
    }
    
}

PARSER_END(FileParser)

//
// (* COMMENTS *)
TOKEN_MGR_DECLS : {
    int commentNestingDepth ; 
}
    
// When a "(*" is encounted in the DEFAULT state, set the counter to 1 and enter the COMMENT state:
SKIP : {  "(*" { commentNestingDepth = 1 ; } : COMMENT }

// When a "(*" is encounted in the COMMENT state, increment the counter:
< COMMENT >  SKIP : {  "(*" { commentNestingDepth += 1 ; } }

// When a "*)" is encountered in the COMMENT state, either switch back to the DEFAULT state or stay in the comment state:
< COMMENT >  SKIP : {  "*)" { commentNestingDepth -= 1; SwitchTo( 
	                          commentNestingDepth==0 ? DEFAULT : COMMENT ) ; } } 

// Finally a rule is needed to mop up all the other characters in the comment.
< COMMENT >  SKIP : {  < ~[] > }


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN :
{

// keywords
  < INCLUDE: "include" >
| < SORT: "sort" >
| < FUNCTION: "function" >
| < BINDER: "binder" >
| < INFIX: "infix" >
| < PREFIX: "prefix" >
| < ASSIGNABLE: "assignable" >
| < UNIQUE: "unique" >
| < PROBLEM: "problem" >
| < RULE: "rule" >
| < FIND: "find" >
| < ASSUME: "assume" >
| < REPLACE: "replace" >
| < REMOVE: "remove" >
| < WHERE: "where" >
| < ADD: "add" >
| < SAMEGOAL: "samegoal" >
| < NEWGOAL: "newgoal" >
| < CLOSE: "closegoal" >
| < DESCRIPTION: "description" >
| < TAGS: "tags" >
// the following are keywords in the inner language. 
// They are added here to prevent people from using them as
// identifiers.
| < AS: "as" >
// ....

// Literals
| < TERM: "{" ( ~["}"] )* "}" >
| < STRING: "\"" ( ~["\""] )* "\"" >
| < NATURAL: ( ["0" - "9"] )+ >

// Logics
| < LEFTPAREN: "(" >
| < RIGHTPAREN: ")" >
| < COMMA: "," >
| < SEMICOLON: ";" >
| < SEP: "|-" >

// Identifiers
| < INTERNAL_IDENTIFIER: "$" <IDENTIFIER> >
| < BINDER_IDENTIFIER: "\\" <IDENTIFIER> >
| < TYVAR_IDENTIFIER: "'" <IDENTIFIER> >
| < OP_IDENTIFIER: ( ["+","-","<",">","&","|","=","*","/","!","^"] )+ >
| < IDENTIFIER: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","0"-"9","_","'"] )* >

//| < OTHER: ["\u0000"-"\uFFFF"] >
// if outer language hides an identifier in the inner language:
| < HIDDEN_IDENTIFIER: "`" <IDENTIFIER> "`" >
  { matchedToken.kind = IDENTIFIER;
  	String s = matchedToken.image;
  	matchedToken.image = s.substring(1, s.length()-1); }
}

//
// structural elements that have nothing to do with Terms
//


ASTFile File():
{
  ASTDeclarationBlock block;
  List<ASTDeclarationBlock> blocks = new ArrayList<ASTDeclarationBlock>();
  ASTRawTerm problem = null;
}
{      (
        ( block=IncludeDeclarationBlock()
        | block=SortDeclarationBlock()
        | block=FunctionDeclarationBlock()
        | block=BinderDeclarationBlock()
        | block=RuleDeclaration()
        )   { blocks.add(block); }
       )*
       
       ( "problem" problem=RawTerm() )?
       
       <EOF>
       
   { return new ASTFile(blocks, problem); }
}

ASTIncludeDeclarationBlock IncludeDeclarationBlock():
{
  Token first;
  Token string;
  List<Token> list = new ArrayList<Token>();
}
{
        first="include" ( string=<STRING> { list.add(string); } )+
          { return new ASTIncludeDeclarationBlock(first, list); }
}

ASTSortDeclarationBlock SortDeclarationBlock():
{
  Token first;
  ASTSortDeclaration sd;
  List<ASTSortDeclaration> list = new ArrayList<ASTSortDeclaration>();
}
{
        first="sort" ( sd=SortDeclaration() { list.add(sd); } )+
          {return new ASTSortDeclarationBlock(first, list); }
}

ASTSortDeclaration SortDeclaration():
{
  Token name, ty;
  List<Token> tyvars = new ArrayList<Token>(); 
}
{
        name=<IDENTIFIER>
        (
          "(" ty=<TYVAR_IDENTIFIER> { tyvars.add(ty); }
             ( "," ty=<TYVAR_IDENTIFIER> { tyvars.add(ty); } )*
          ")"
        )?
        { return new ASTSortDeclaration(name, tyvars); }
}

ASTFunctionDeclarationBlock FunctionDeclarationBlock():
{
  Token first;
  ASTFunctionDeclaration fd;
  List<ASTFunctionDeclaration> list = new ArrayList<ASTFunctionDeclaration>();
}
{
        first = "function" ( fd=FunctionDeclaration() { list.add(fd); } )+
           { return new ASTFunctionDeclarationBlock(first, list); }
}

ASTFunctionDeclaration FunctionDeclaration():
{
  Token name, as = null, modifier = null, precedence = null;
  ASTType range, ty;
  List<ASTType> tyrefs = new ArrayList<ASTType>();
}
{
        range=TypeReference()
        
        ( name=<IDENTIFIER> | name=<INTERNAL_IDENTIFIER> )
        
        (
          "(" ty=TypeReference() { tyrefs.add(ty); }
             ( "," ty=TypeReference() { tyrefs.add(ty); } )*
          ")"
        )?
        
        (
          modifier="infix" as=<OP_IDENTIFIER>  precedence=<NATURAL>
        |
          modifier="prefix" as=<OP_IDENTIFIER>  precedence=<NATURAL>
        |
          modifier="assignable"
        |
          modifier="unique"
        )?
        
    { 
      return new ASTFunctionDeclaration(range, name, tyrefs, modifier, as, precedence);
    }
}

ASTBinderDeclarationBlock BinderDeclarationBlock():
{
  Token first;
  ASTBinderDeclaration bd;
  List<ASTBinderDeclaration> list = new ArrayList<ASTBinderDeclaration>();
}
{
	first="binder" ( bd=BinderDeclaration() { list.add(bd); } )+
	   { return new ASTBinderDeclarationBlock(first, list); }
}

ASTBinderDeclaration BinderDeclaration():
{
  ASTType range, varty, ty;
  Token name;
  List<ASTType> tyrefs = new ArrayList<ASTType>();
}
{
	range=TypeReference() "("
        
    name=<BINDER_IDENTIFIER>
    
    varty=TypeReference()
     
    ( ";" ty=TypeReference() { tyrefs.add(ty); } )+

    ")"

    { return new ASTBinderDeclaration(name, range, varty, tyrefs); }
}


ASTRawTerm RawTerm():
{
  Token token;
}
{
   token=<TERM> { return new ASTRawTerm(token); }
}

ASTType TypeReference():
{
  Token token;
  ASTType ty;
  List<ASTType> args = new ArrayList<ASTType>();
}
{
  (
     token=<IDENTIFIER>
     ( LOOKAHEAD(2)  // might have a binder id in a binder declaration
        "(" ty=TypeReference() { args.add(ty); }
             ( "," ty=TypeReference() { args.add(ty); } )*
        ")"
     )?
      { return new ASTTypeRef(token, args); }
   |
     token=<TYVAR_IDENTIFIER>
      { return new ASTTypeVar(token); }
  )
}


ASTRule RuleDeclaration():
{
  List<ASTRuleElement> list = new ArrayList<ASTRuleElement>();
  List<ASTGoalAction> actions = new ArrayList<ASTGoalAction>();
  List<ASTRuleElement> aclist;
  List<Pair<Token, Token>> properties = new ArrayList<Pair<Token, Token>>();
  ASTGoalAction action;
  ASTRuleElement elem;
  ASTLocatedTerm lt;
  Token t, v = null, first, name, descr = null;
}
{
  first="rule" name=<IDENTIFIER>
  (
    t="find" lt=LocatedTerm(true) { list.add(new ASTRuleFind(t, lt)); }
  | t="assume" lt=LocatedTerm(false) { list.add(new ASTRuleAssume(t, lt)); }
  | t="where" ( elem=WhereClause(t) { list.add(elem); } )+ 
  )+
  
  (
    t="closegoal" { actions.add(new ASTGoalAction(t)); }
  | (t="samegoal" | t="newgoal") ( v=<STRING> )? aclist=AddReplaces() 
         { actions.add(new ASTGoalAction(t, v, aclist)); }
  )+
  
  (
    "description" descr=<STRING>
  )?
  
  (
    "tags" 
    ( 
      t=<IDENTIFIER> v=<STRING>
        { properties.add(new Pair<Token, Token>(t, v)); } 
    )+
  )?
  
  { return new ASTRule(first, name, list, actions, descr, properties); }
}

ASTLocatedTerm LocatedTerm(boolean bothAllowed):
{
	ASTRawTerm rt;
}
{
      LOOKAHEAD(2) rt=RawTerm() "|-"
        { return new ASTLocatedTerm(rt, MatchingLocation.ANTECEDENT); }
    | "|-" rt=RawTerm()
        { return new ASTLocatedTerm(rt, MatchingLocation.SUCCEDENT); }
    | LOOKAHEAD({bothAllowed}) rt=RawTerm()
        { return new ASTLocatedTerm(rt, MatchingLocation.BOTH); }
}

List<ASTRuleElement> AddReplaces():
{
	Token t;
	ASTRawTerm rt;
	ASTLocatedTerm lt;
	List<ASTRuleElement> list = new ArrayList<ASTRuleElement>();
}
{
  (
    t="add" lt=LocatedTerm(false) { list.add(new ASTRuleAdd(t, lt)); }
  | t="replace" rt=RawTerm() { list.add(new ASTRuleReplace(t, rt)); }
  | t="remove" { list.add(new ASTRuleRemove(t)); }
  )+
  { return list; }
}

ASTWhereClause WhereClause(Token headToken):
{
	Token t;
	ASTRawTerm rt;
	List<ASTRawTerm> args = new ArrayList<ASTRawTerm>();
}
{
	   t=<IDENTIFIER>
	   ( rt=RawTerm() { args.add(rt); } ) +
       { return new ASTWhereClause(headToken, t, args); }	   
}
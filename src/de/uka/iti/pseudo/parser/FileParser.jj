

//
// This file contains the grammar for files with sorts/functions/rules/program and problem definitions
// structural elements that have nothing to do with Terms
//


ASTFile File():
{
  ASTDeclarationBlock block;
  List<ASTDeclarationBlock> blocks = new ArrayList<ASTDeclarationBlock>();
  ASTTerm problem = null;
  ASTStatementList program = null;
}
{      (
        ( block=IncludeDeclarationBlock()
        | block=SortDeclarationBlock()
        | block=FunctionDeclarationBlock()
        | block=BinderDeclarationBlock()
        | block=RuleDeclaration()
        )   { blocks.add(block); }
       )*
       
       ( "program" program=StatementList() )?
       
       ( "problem" problem=Term() )?
       
       <EOF>
       
   { return new ASTFile(blocks, program, problem); }
}

ASTIncludeDeclarationBlock IncludeDeclarationBlock():
{
  Token first;
  Token string;
  List<Token> list = new ArrayList<Token>();
}
{
        first="include" ( string=<STRING> { list.add(string); } )+
          { return new ASTIncludeDeclarationBlock(first, list); }
}

ASTSortDeclarationBlock SortDeclarationBlock():
{
  Token first;
  ASTSortDeclaration sd;
  List<ASTSortDeclaration> list = new ArrayList<ASTSortDeclaration>();
}
{
        first="sort" ( sd=SortDeclaration() { list.add(sd); } )+
          {return new ASTSortDeclarationBlock(first, list); }
}

ASTSortDeclaration SortDeclaration():
{
  Token name, ty;
  List<Token> tyvars = new ArrayList<Token>(); 
}
{
        name=<IDENTIFIER>
        (
          "(" ty=<TYVAR_IDENTIFIER> { tyvars.add(ty); }
             ( "," ty=<TYVAR_IDENTIFIER> { tyvars.add(ty); } )*
          ")"
        )?
        { return new ASTSortDeclaration(name, tyvars); }
}

ASTFunctionDeclarationBlock FunctionDeclarationBlock():
{
  Token first;
  ASTFunctionDeclaration fd;
  List<ASTFunctionDeclaration> list = new ArrayList<ASTFunctionDeclaration>();
}
{
        first = "function" ( fd=FunctionDeclaration() { list.add(fd); } )+
           { return new ASTFunctionDeclarationBlock(first, list); }
}

ASTFunctionDeclaration FunctionDeclaration():
{
  Token name, as = null, modifier = null, precedence = null;
  ASTType range, ty;
  List<ASTType> tyrefs = new ArrayList<ASTType>();
}
{
        range=TypeRef()
        
        ( name=<IDENTIFIER> | name=<INTERNAL_IDENTIFIER> )
        
        (
          "(" ty=TypeRef() { tyrefs.add(ty); }
             ( "," ty=TypeRef() { tyrefs.add(ty); } )*
          ")"
        )?
        
        (
          modifier="infix" as=<OP_IDENTIFIER>  precedence=<NATURAL>
        |
          modifier="prefix" as=<OP_IDENTIFIER>  precedence=<NATURAL>
        |
          modifier="assignable"
        |
          modifier="unique"
        )?
        
    { 
      return new ASTFunctionDeclaration(range, name, tyrefs, modifier, as, precedence);
    }
}

ASTBinderDeclarationBlock BinderDeclarationBlock():
{
  Token first;
  ASTBinderDeclaration bd;
  List<ASTBinderDeclaration> list = new ArrayList<ASTBinderDeclaration>();
}
{
	first="binder" ( bd=BinderDeclaration() { list.add(bd); } )+
	   { return new ASTBinderDeclarationBlock(first, list); }
}

ASTBinderDeclaration BinderDeclaration():
{
  ASTType range, varty, ty;
  Token name;
  List<ASTType> tyrefs = new ArrayList<ASTType>();
}
{
	range=TypeRef() "("
        
    name=<BINDER_IDENTIFIER>
    
    varty=TypeRef()
     
    ( ";" ty=TypeRef() { tyrefs.add(ty); } )+

    ")"

    { return new ASTBinderDeclaration(name, range, varty, tyrefs); }
}

ASTRule RuleDeclaration():
{
  List<ASTRuleElement> list = new ArrayList<ASTRuleElement>();
  List<ASTGoalAction> actions = new ArrayList<ASTGoalAction>();
  List<ASTRuleElement> aclist;
  List<Pair<Token, Token>> properties = new ArrayList<Pair<Token, Token>>();
  ASTRuleElement elem;
  ASTLocatedTerm lt;
  Token t, v = null, first, name, descr = null, target = null;
}
{
  first="rule" name=<IDENTIFIER>
  
  (
    t="find" lt=LocatedTerm(true) { list.add(new ASTRuleFind(t, lt)); }
  | t="assume" lt=LocatedTerm(false) { list.add(new ASTRuleAssume(t, lt)); }
  | t="where" ( elem=WhereClause(t) { list.add(elem); } )+
  )+
  
  (
    (
      t="closegoal" { actions.add(new ASTGoalAction(t)); }
    | (target="samegoal" | target="newgoal") ( v=<STRING> )? aclist=AddReplaces() 
           { actions.add(new ASTGoalAction(target, v, aclist)); }
    )+
  | 
    aclist = AddReplaces()  // implicit samegoal
      { actions.add(new ASTGoalAction(null, null, aclist)); }
  )
  
  (
    "description" descr=<STRING>
  )?
  
  (
    "tags" 
    ( 
      t=<IDENTIFIER> ( v=<STRING> )?
        { properties.add(new Pair<Token, Token>(t, v));
          v = null; } 
    )+
  )?
  
  { return new ASTRule(first, name, list, actions, descr, properties); }
}

ASTLocatedTerm LocatedTerm(boolean bothAllowed):
{
	ASTTerm rt;
}
{
      "|-" rt=Term()
        { return new ASTLocatedTerm(rt, MatchingLocation.SUCCEDENT); }
    |
      rt=Term() 
        ( "|-" 
           { return new ASTLocatedTerm(rt, MatchingLocation.ANTECEDENT); } )?
      { if(!bothAllowed) {
          generateParserException(new int[] { SEP });
        }
        return new ASTLocatedTerm(rt, MatchingLocation.BOTH); }
}

List<ASTRuleElement> AddReplaces():
{
	Token t;
	ASTTerm term;
	ASTLocatedTerm lt;
	List<ASTRuleElement> list = new ArrayList<ASTRuleElement>();
}
{
  ( 
    t="add" lt=LocatedTerm(false) { list.add(new ASTRuleAdd(t, lt)); }
  | t="replace" term=Term() { list.add(new ASTRuleReplace(t, term)); }
  | t="remove" { list.add(new ASTRuleRemove(t)); }
  )+
  { return list; }
}

ASTWhereClause WhereClause(Token headToken):
{
	Token t;
	ASTTerm term;
	List<ASTTerm> args = new ArrayList<ASTTerm>();
}
{
       t=<IDENTIFIER>
       ( "(" 
             term=Term() { args.add(term); } 
             ( "," term=Term() { args.add(term); } )*
         ")" )?
       { return new ASTWhereClause(headToken, t, args); }   
}

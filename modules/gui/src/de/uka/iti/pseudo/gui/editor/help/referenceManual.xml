<ivildoc>
  <category name="Environment property">
    <entry name="order">
      <![CDATA[
 
 Use the property <tt>order.<i>fct</i></tt> to specify the order ... 
 TODO IVILDOC]]>
    </entry>
    <entry name="stopAtSkip">
      <![CDATA[
 
 The environment property <tt>BreakpointStrategy.stopAtSkip</tt> can be
 used to specify whether symbolic execution should stop whenever reaching
 a <tt>skip</tt> statement. The value can be "<code>true</code>" or "
 <code>false</code>".]]>
    </entry>
    <entry name="obeySourceBreakpoints">
      <![CDATA[
 
 The environment property
 <tt>BreakpointStrategy.obeySourceBreakpoints</tt> can be used to specify
 whether symbolic execution breakpoints set on level of the source code
 program are to be enabled. The value can be "<code>true</code>" or "
 <code>false</code>".]]>
    </entry>
    <entry name="stopAtLoop">
      <![CDATA[
 
 The environment property <tt>BreakpointStrategy.stopAtSkip</tt> can be
 used to specify whether symbolic execution should stop whenever reaching
 a goto statement of which one target lies before the current location.
 This happens usually only at the end of a loop. The value can be "
 <code>true</code>" or " <code>false</code>".]]>
    </entry>
    <entry name="obeyProgramBreakpoints">
      <![CDATA[
 
 The environment property
 <tt>BreakpointStrategy.obeyProgramBreakpoints</tt> can be used to specify
 whether symbolic execution breakpoints set on level of the ivil program
 are to be enabled. The value can be "<code>true</code>" or "
 <code>false</code>".]]>
    </entry>
  </category>
  <category name="Rule tag">
    <entry name="rewrite">
      <![CDATA[ 
 
 <h2>Rule tag <tt>rewrite</tt></h2>
 
 "rewrite" expects a string argument.
 
 <p>
 It declares the set of rewrite rules to which a rule belongs. They list
 of known rule sets include the following:
 <ol>
 <li>"updSimpl" - update simplification</li>
 <li>"close" - rules to close goals</li>
 <li>"concrete" - rules involving operations on constants (
 <tt>false | a</tt> to <tt>a</tt>)</li>
 <li>"prop simp" - propositional simplification</li>
 <li>"fol simp" - first order simplification</li>
 </ol>
 Rule sets are applied in that order by the simplification strategy.
 There are other rule sets for more specific purposes. "symbex" is used
 for symbolic execution for instance.]]>
    </entry>
    <entry name="autoonly">
      <![CDATA[
 
 <h2>Rule tag <tt>autoonly</tt></h2>
 
 "autoonly" does not take an argument.
 
 <p>It makes a rule invisible for manual application.]]>
    </entry>
    <entry name="decisionProcedure">
      <![CDATA[
 
 <h2>Rule tag <tt>decisionProcedure</tt></h2>
 
 "decisionProcedure" expects a classname as argument.
 
 <p>It denotes the decision procedure plugin to instantiate.]]>
    </entry>
    <entry name="hintsOnBranches">
      <![CDATA[
 
 <h2>Rule tag <tt>hintsOnBranches</tt></h2>
 
 "hintsOnBranches" takes a comma separated list of integer numbers as
 argument. It is used by the proof hint strategy to decide on which child
 branches hints are to be applied. The first child branch has number "0".]]>
    </entry>
    <entry name="asAxiom">
      <![CDATA[
 
 <h2>Rule tag <tt>asAxiom</tt></h2>
 
 "asAxiom" does not take an argument.
 
 <p>It marks a rule to be translated into an axiom which allows it to
 be translated to SMT. This is not possible for all rules.]]>
    </entry>
    <entry name="derived">
      <![CDATA[
 
 <h2>Rule tag <tt>derived</tt></h2>
 
 "derived" does not an need argument.
 
 <p>It marks a rule to be inferrable by the rules preceeding it (plus
 includes)]]>
    </entry>
    <entry name="display">
      <![CDATA[ 
 
 <h2>Rule tag <tt>display</tt></h2>
 
 "display" expects a string as argument,
 possibly with embedded schema variables.
 
 <p>
 This string is used to annotate history entries and proof tree component
 labels.
 
 <p>The format is the following:
 <table>
 <tr>
 <th>Text</th>
 <th>Replacement</th>
 </tr>
 <tr>
 <td>{%c}</td>
 <td>The text representation of the instantiation for the schema variable,
 "??" if not instantiated.</td>
 </tr>
 <tr>
 <td>{explain %c}</td>
 <td>The text representation of the annotation statement to which %c points
 (if it does exists). Empty string otherwise.</td>
 </tr>
 <tr>
 <td>{explainOrQuote %c}</td>
 <td>The text representation of the annotation statement to which %c points
 (if it does). The statement otherwise. Empty string if %c does not hold a
 program term.</td>
 </tr>
 <tr>
 <td>{property name}</td>
 <td>The value of the named property of the rule application.</td>
 </tr>
 <tr>
 <td>{upd U}</td>
 <td>The textual representation of the value of the instantiation of the
 schema update.</td>
 </tr>
 </table>]]>
    </entry>
    <entry name="fromRule">
      <![CDATA[
 
 <h2>Rule tag <tt>fromRule</tt></h2>
 
 "fromRule" takes a rule name as argument.
 
 <p>It is added automatically to axioms which are generated automatically
 from rules. The argument is set to the name of the originating rule.]]>
    </entry>
    <entry name="prio">
      <![CDATA[ "prio" expects an integer as argument.
 
 <h2>Rule tag <tt>prio</tt></h2>
          <p>
          When sorting rules, the priority is used as comparison
          criterion.
          <p>
          Priorities have to be between 100 and 999, where higher priority
          means the rule is likelier to be applied.]]>
    </entry>
    <entry name="timeout">
      <![CDATA[
 <h2>Rule tag <tt>timeout</tt></h2>
 
 "timeout" expects an integer as argument.
 
 <p>For decision procedure rules. The time to wait before shutting down the
 DP.]]>
    </entry>
    <entry name="verbosity">
      <![CDATA[
 
 <h2>Rule tag <tt>verbosity</tt></h2>
 
 "verbosity" expects an integer as argument.
 
 <p>It defines from which verbosity level on the rule is printed in the proof
 component.]]>
    </entry>
  </category>
  <category name="Proof hint">
    <entry name="">
      <![CDATA[ <h1>Proof hints</h1>
 
 Proof hints allow the user to dynamically configure the strategy in use. They
 are usually added as annotations to <tt>assert</tt> statements. The branch
 handling the proof obligation for the asserted formula is then treated
 differently to the rest of the proof. The exact nature of this different
 behaviour depends on the configuration of the hints. They can take string
 arguments.]]>
    </entry>
    <entry name="rule">
      <![CDATA[
 
 <h2>Proof hint <code>cut</code></h2>
 
 In order to perform a certain rule on a branch, this hint can be used.
 
 <h3>Arguments</h3>
 cut takes one argument which is the name of the rule to be applied.
 
 <h3>Example</h3>
 <pre>
 assert emptyset &lt;: SetM ; "use the lemma ยง(rule emptyset_lemma)"
 </pre>]]>
    </entry>
    <entry name="cut">
      <![CDATA[
 
 <h2>Proof hint <code>cut</code></h2>
 
 In order to perform a case distinction on a branch, this hint can be used.
 
 <h3>Arguments</h3>
 cut takes one argument which is the formula upon which to perform the cut.
 
 <h3>Example</h3>
 <pre>
 assert x*x >= 0 ; "examine by sign ยง(cut 'x >= 0')"
 </pre>]]>
    </entry>
  </category>
  <category name="Where condition">
    <entry name="">
      <![CDATA[
 
          <h1>Where conditions</h1>
 
          Where conditions are used to formulate constraints von schema
          instantiations in rule definitions. They describe conditions on the
          matched terms under which the rule may be applied.
 
          <p>
          Where conditions can take arguments, but do not have to. For some
          conditions, <i>marker arguments</i> (schema variables with special
          names) can be used to specify a particular behaviour of a condition.
 
          <h3>Example</h3>
 
          The where condition<br/>
          <tt>&nbsp;&nbsp;&nbsp;where intLiteral %a</tt><br/>
 
          in a rule makes the rule only applicable if the schema variable %a
          is instantiated with an integer literal.
 
          <h2>Active where conditions</h2>
 
          Where conditions cannot only check the instantiation context but
          also act and actively modify it.
 
          <p>
          An active where condition can add new schema instantiations to the
          context. Existing schema instantiations will not be changed, only
          new entries added. Please note that active conditions can also fail
          and not accept an instantiation.
 
          <p>
          The documentation will point out which parameters are active, and
          which are passive. Future syntax changes may make the distinction
          clearer.
 
          <h3>Example</h3>
 
          The where condition<br/>
          <tt>&nbsp;&nbsp;&nbsp;freshVar %z, %condition</tt><br/>
 
          instantiates <code>%z</code> with a variable of the same type which
          does not appear (bound or unbound) in the instantiation of
          <code>%condition</code>.]]>
    </entry>
    <entry name="toplevel">
      <![CDATA[
 
 <h2>Where condition <tt>toplevel</tt></h2>
 
 This condition can be used to ensure that the term which matches the find
 clause is not within the reach of an update or program modality.
 
 <h3>Syntax</h3> The where condition expects no arguments.
 
 <h3>Example:</h3>
 
 <pre>
   rule apply_equality 
   assume %a=%b |-
   where toplevel
   find %a
   replace %b
 </pre>
 
 The equality <tt>a=5</tt> must not be applied to replace the second
 <code>a</code> in the expression <tt>{a:=7}a=5</tt>
 
 <h3>See also:</h3>
 
 <h3>Result:</h3> <code>true</code> if the find clause of the rule matches
 against a term which is not in the scope of an update or a program modality,
 <code>false</code> otherwise. Does not fail.]]>
    </entry>
    <entry name="freshVar">
      <![CDATA[
 
 <h2>Where condition <tt>freshVar</tt></h2>
 
 This condition can be used to ensure that a variable does not occur free nor
 bound in terms.
 
 <p>
 This is an example of an <em>active</em> condition since it may add variable
 instantiations. If the first formal parameter is a schema variable, it
 becomes instantiated with a new variable of the same type which does not
 occur in the arguments.
 
 <p>
 The resulting variable is named after the first parameter to the condition,
 possibly with an added number as suffix.
 
 <h3>Syntax</h3> The where condition expects a first parameter which can
 either be a variable or a schema variable. Any number of arbitrary terms may
 follow.
 
 <h3>Example:</h3>
 
 <pre>
   sort S
   function bool p(S, S) 
   function bool allP(S)
   
   rule quant_definition
   find allP(%s1, %s2)
   where freshVar %x, %s2
   replace (\forall %x; p(%x, %s2))
 </pre>
 
 <h3>See also:</h3>
 
 <h3>Result:</h3>
 <code>true</code> if the first argument (or its instantiation) is (or has
 been chosen by this condition) a variable which does not occur in the
 remaining arguments. It fails if the first argument is not matched by a
 variable.]]>
    </entry>
    <entry name="noFreeVars">
      <![CDATA[
 
 <h2>Where condition <tt>noFreeVars</tt></h2>
 This condition can be used to ensure that a term contains no unbound variables.
 
 <h3>Syntax</h3>
 The where condition expects exactly one argument of any type.
 This can be a schema variable.
 
 <h3>Example:</h3>
 <pre>
   rule cut_cond
     find cond(%c, %a, %b)
   where 
     toplevel
   where
     noFreeVars(%c)
   samegoal "Assume true for {%c}"
     add %c |-
     replace %a
   samegoal "Assume false for {%c}"
     add |- %c
 </pre>
 
 <h3>See also:</h3>
 <a href="ivil:/Meta function/freshVar">freshVar</a>
 
 <h3>Result:</h3>
 
 <code>true</code> if the argument has no free variables, 
 <code>false</code> otherwise,
 never fails.]]>
    </entry>
    <entry name="presentInSuccedent">
      <![CDATA[
 
 <h2>Where condition <tt>presentInSuccedent</tt></h2>
 
 This condition can be used to ensure that a formula is present in 
 the succedent of the sequent.
 
 <p>
 A formula is considered to be present if it appears toplevel and
 syntactically equal on the sequent.
 
 <p>
 If more than one argument is provided, the check will be performed for all
 arguments. The result will be <code>true</code> only if all arguments pass
 it.
 
 <h3>Syntax</h3> The where condition expects one or more boolean terms as
 arguments.
 
 <h3>Example:</h3>
 
 <pre>
   function int card(set('a))
   
   rule nonneg_cardinality
   find card(%x)
   where not presentInSuccedent card(%x) < 0
   add |- card(%x) < 0 
 </pre>
 
 <h3>See also:</h3>
 <a href="ivil:/Where condition/presentInSequent">presentInSequent</a>,
 <a href="ivil:/Where condition/presentInAntecedent">presentInAntecedent</a>
 
 <h3>Result:</h3>
 <code>true</code> if the all arguments appear toplevel in the sequent,
 <code>false</code> otherwise. Does never fail.]]>
    </entry>
    <entry name="intLiteral">
      <![CDATA[
 
 <h2>Where condition <tt>intLiteral</tt></h2>
 This condition can be used to ensure that a term of integer type is a
 number literal.
 
 <h3>Syntax</h3>
   The where condition expects exactly one argument of type integer.
   This can be a schema variable.
 
 <h3>Example:</h3>
 <pre>
   rule add_literal
   find %a + %b
   where intLiteral %a
         intLiteral %b
   replace $$intEval(%a + %b)
 </pre>
 
 <h3>See also:</h3>
 <a href="ivil:/Meta function/intEval">intEval</a>
 
 <h3>Result:</h3>
 
 <code>true</code> if the argument is a number literal, 
 <code>false</code> otherwise,
 never fails.]]>
    </entry>
    <entry name="distinctAssumeAndFind">
      <![CDATA[
 
 <h2>Where condition <tt>distinctAssumeAndFind</tt></h2>
 
 This condition can be used to ensure that the find clause does not match the
 same as any of the assume clauses.
 
 <h3>Syntax</h3> The where condition expects no arguments.
 
 <h3>Example:</h3>
 
 <pre>
   rule replace_known_left
   assume  %b |-
   find    %b 
   where   toplevel
   where   distinctAssumeAndFind
   replace true
 </pre>
 
 This prevents from replacing an antecedent
 
 <h3>See also:</h3> <a href="ivil:/Where condition/toplevel">toplevel</a>
 
 <h3>Result:</h3>
 
 <code>true</code> if the find clauses does not match the same as an assume
 clause. <code>false</code> if the find clause matches against the same term
 in a sequent as an assumption.]]>
    </entry>
    <entry name="presentInSequent">
      <![CDATA[
 
 <h2>Where condition <tt>presentInSequent</tt></h2>
 
 This condition can be used to ensure that a formula is present either in the
 antecedent or the succedent of the sequent.
 
 <p>
 A formula is considered to be present if it appears toplevel and
 syntactically equal on the sequent.
 
 <p>
 If more than one argument is provided, the check will be performed for all
 arguments. The result will be <code>true</code> only if all arguments pass
 it.
 
 <h3>Syntax</h3> The where condition expects one or more boolean terms as
 arguments.
 
 <h3>Example:</h3>
 
 <pre>
   function int f(int)
   
   rule cut_f_zero
   find f(%x)
   where not presentInSequent f(%x)
   samegoal add f(%x) = 0 |-
   samegoal add |- f(%x) = 0
 </pre>
 
 <h3>See also:</h3>
 <a href="ivil:/Where condition/presentInAntecedent">presentInAntecedent</a>,
 <a href="ivil:/Where condition/presentInSuccedent">presentInSuccedent</a>
 
 <h3>Result:</h3>
 <code>true</code> if the all arguments appear toplevel in the sequent,
 <code>false</code> otherwise. Does never fail.]]>
    </entry>
    <entry name="axiom">
      <![CDATA[
 
 <h2>Where condition <tt>axiom</tt></h2>
 
 This condition can be used to ensure that a term has been defined as an
 axiom.
 
 <p>
 In addition to giving the term of an axiom, the property "axiomName" must be
 set on the rule application
 
 <h3>Syntax</h3> The where condition expects one parameter.
 
 <h3>Example:</h3>
 The condition is used in the rule
 
 <pre>
   rule `axiom`
   where `axiom` %b
   add %b |-
   tags autoonly
        display "Insert axiom {property axiomName}"
 </pre>
 
 (axiom needs to back-quoted since it is a keyword)
 
 <h3>See also:</h3> <a href="ivil:/Rule property/asAxiom">asAxiom</a>
 
 <h3>Result:</h3>
 
 <code>true</code> if the argument has been declared as axiom under the
 specified name. Fails otherwise.]]>
    </entry>
    <entry name="presentInAntecedent">
      <![CDATA[
 
 <h2>Where condition <tt>presentInAntecedent</tt></h2>
 
 This condition can be used to ensure that a formula is present either in the
 antecedent or the succedent of the sequent.
 
 <p>
 A formula is considered to be present if it appears toplevel and
 syntactically equal on the sequent.
 
 <p>
 If more than one argument is provided, the check will be performed for all
 arguments. The result will be <code>true</code> only if all arguments pass
 it.
 
 <h3>Syntax</h3> The where condition expects one or more boolean terms as
 arguments.
 
 <h3>Example:</h3>
 
 <pre>
   function int card(set('a))
   
   rule positive_cardinality
   find card(%x)
   where not presentInAntecedent card(%x) >= 0
   add card(%x) >= 0 |-
 </pre>
 
 <h3>See also:</h3>
 <a href="ivil:/Where condition/presentInSequent">presentInSequent</a>,
 <a href="ivil:/Where condition/presentInSuccedent">presentInSuccedent</a>
 
 <h3>Result:</h3>
 <code>true</code> if the all arguments appear toplevel in the sequent,
 <code>false</code> otherwise. Does never fail.]]>
    </entry>
  </category>
</ivildoc>
